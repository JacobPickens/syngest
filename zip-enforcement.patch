--- a/dump-apply.js
+++ b/dump-apply.js
@@ -2,6 +2,7 @@
 import path from "path";
 import zlib from "zlib";
 import { TOOLCHAIN_VERSION } from "./toolchain-version.js";
+import { extractSingleFileZip } from "./zip-util.js";

 const HEADER = "CHITDUMPv1\n";
 const PAYLOAD_MARKER = "\n---PAYLOAD---\n";
@@ -63,3 +64,39 @@
     fs.writeFileSync(fullPath, content, "utf8");
   }
 }
+
+/**
+ * Apply a ZIP containing EXACTLY one file: dump.txt
+ * (Multipart zips are forbidden.)
+ */
+export function applyDumpZip(zipBuffer) {
+  if (!Buffer.isBuffer(zipBuffer)) {
+    throw new Error("applyDumpZip expects a Buffer");
+  }
+  const { data } = extractSingleFileZip(zipBuffer, "dump.txt");
+  const dumpText = data.toString("utf8");
+  return applyDump(dumpText);
+}
+
+/**
+ * Auto-detects whether the input is a raw dump string or a ZIP buffer.
+ * - If Buffer begins with PK\x03\x04 => ZIP
+ * - Else if string starts with CHITDUMPv1 => dump
+ */
+export function applyDumpAuto(input) {
+  if (Buffer.isBuffer(input)) {
+    // ZIP signature: 0x50 0x4b 0x03 0x04
+    if (input.length >= 4 && input[0] === 0x50 && input[1] === 0x4b && input[2] === 0x03 && input[3] === 0x04) {
+      return applyDumpZip(input);
+    }
+    // Otherwise treat as UTF-8 dump text buffer
+    return applyDump(input.toString("utf8"));
+  }
+
+  if (typeof input === "string") {
+    if (input.startsWith(HEADER)) return applyDump(input);
+    throw new Error("applyDumpAuto: string input must be dump text");
+  }
+
+  throw new Error("applyDumpAuto: unsupported input type");
+}
--- a/GPT-CONTRACT.txt
+++ b/GPT-CONTRACT.txt
@@ -35,20 +35,21 @@
 2) ZIP CONTENTS REQUIREMENTS
 ============================

-2.1 Required contents
+2.1 Required contents (SINGLE-DUMP ONLY)

-The INPUT ZIP MUST be treated as a complete snapshot container that includes:
+The INPUT ZIP is valid ONLY if it contains EXACTLY ONE file:

-A) Exactly one authoritative dump file:
+* dump.txt

-* Preferred name: dump.txt
-* Allowed name: dump_vX.Y.Z.txt (matching the ZIP's version)
+No other entries are allowed:

-B) Optional ancillary files (allowed but non-authoritative):
+* no README
+* no notes
+* no extra metadata files
+* no folders
+* no alternate dump filenames

-* README.txt or README.md
-* notes.txt
-* Any other files, BUT the DUMP remains the sole source of truth.
+Multipart ZIPs are FORBIDDEN.

 2.2 Authoritative dump inside ZIP

@@ -60,16 +61,34 @@
 * re-generating a new valid dump.txt
 * packaging that dump.txt into the OUTPUT ZIP

+2.3 Toolchain-enforced packaging (HARD RULE)
+
+ChatGPT MUST use the embedded dump scripts as the ONLY authoritative implementation of:
+
+* dump generation
+* ZIP packaging
+* ZIP validation / unpackaging
+
+In particular:
+
+* The OUTPUT ZIP MUST be the byte-for-byte output of the embedded generator ZIP routine
+  (generateDumpZip / writeDumpZip semantics).
+* The INPUT ZIP MUST be validated and unpacked using the embedded apply/validator ZIP routines
+  (applyDumpZip / validateZip semantics).
+* ChatGPT MUST NOT hand-roll or “approximate” ZIP structure, CRCs, headers, etc.
+  The embedded scripts define the canonical format.
+
 ============================================================
 3) OUTPUT RULE (WHAT CHATGPT MUST RETURN)
 =========================================

 When I request a multi-file change:

-* Output ONLY a downloadable file named: dump_vX.Y.Z.zip
+* Output ONLY a downloadable file named: dump_vA.B.C.zip
 * Do NOT paste the full dump contents inline in chat.
 * You may describe what changed in normal chat, but the ZIP itself must be returned as the downloadable artifact.

+The OUTPUT ZIP MUST contain EXACTLY ONE file:

 * dump.txt

@@ -99,6 +118,18 @@

 This rule is absolute and overrides any ambiguity about “rezipping” or “packaging.”

+4.1 Code-change requirement (HARD RULE)
+
+If ChatGPT outputs a new ZIP (i.e. not a no-op), it MUST include a real codebase change.
+Meta-only changes do NOT count.
+
+Specifically:
+
+* At least one repo file's content (inside dump.txt) MUST differ from the INPUT dump.txt.
+* Bumping version / timestamps / meta fields without changing any repo file content is INVALID.
+* If the request produces no repo file changes, ChatGPT MUST NOT create a new ZIP.
+  It MUST report the request as a no-op.
+
 ============================================================
 5) VERSIONING RULES (HARD RULES)
 ================================
@@ -122,8 +153,7 @@

 The DUMP inside MUST be either:

-* dump.txt, OR
-* dump_vA.B.C.txt
+* dump.txt (ONLY)

 But the **META**.version MUST be "vA.B.C" and MUST match the OUTPUT ZIP version.

--- a/zip-util.js
+++ b/zip-util.js
@@ -0,0 +1,228 @@
+import zlib from "zlib";
+
+// Minimal ZIP (PKZIP) utilities with zero dependencies.
+// Supports reading/writing a ZIP containing exactly one file.
+
+const SIG_LOCAL_FILE = 0x04034b50;
+const SIG_CENTRAL_DIR = 0x02014b50;
+const SIG_END_CENTRAL_DIR = 0x06054b50;
+
+function u16(buf, off) {
+  return buf.readUInt16LE(off);
+}
+
+function u32(buf, off) {
+  return buf.readUInt32LE(off);
+}
+
+function writeU16(n) {
+  const b = Buffer.alloc(2);
+  b.writeUInt16LE(n >>> 0, 0);
+  return b;
+}
+
+function writeU32(n) {
+  const b = Buffer.alloc(4);
+  b.writeUInt32LE(n >>> 0, 0);
+  return b;
+}
+
+// CRC32 implementation (table-driven)
+let CRC32_TABLE = null;
+
+function crc32Table() {
+  if (CRC32_TABLE) return CRC32_TABLE;
+  const table = new Uint32Array(256);
+  for (let i = 0; i < 256; i++) {
+    let c = i;
+    for (let k = 0; k < 8; k++) {
+      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
+    }
+    table[i] = c >>> 0;
+  }
+  CRC32_TABLE = table;
+  return table;
+}
+
+export function crc32(buf) {
+  const table = crc32Table();
+  let c = 0xffffffff;
+  for (let i = 0; i < buf.length; i++) {
+    c = table[(c ^ buf[i]) & 0xff] ^ (c >>> 8);
+  }
+  return (c ^ 0xffffffff) >>> 0;
+}
+
+function isZipBuffer(buf) {
+  return Buffer.isBuffer(buf) && buf.length >= 4 && buf.readUInt32LE(0) === 0x04034b50;
+}
+
+/**
+ * Create a ZIP buffer that contains EXACTLY one file.
+ *
+ * - No data descriptor
+ * - No encryption
+ * - UTF-8 filename flag set
+ */
+export function createSingleFileZip(filename, data, options = {}) {
+  if (typeof filename !== "string" || filename.length === 0) {
+    throw new Error("ZIP filename must be a non-empty string");
+  }
+  if (!Buffer.isBuffer(data)) {
+    throw new Error("ZIP data must be a Buffer");
+  }
+
+  const compress = options.compress !== false;
+  const nameBuf = Buffer.from(filename, "utf8");
+
+  const crc = crc32(data);
+  const uncompressedSize = data.length;
+  const method = compress ? 8 : 0; // 8 = deflate, 0 = store
+
+  const payload = compress ? zlib.deflateRawSync(data) : data;
+  const compressedSize = payload.length;
+
+  // Local file header
+  // https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
+  const localHeader = Buffer.concat([
+    writeU32(SIG_LOCAL_FILE),
+    writeU16(20), // version needed
+    writeU16(0x0800), // general purpose bit flag (UTF-8)
+    writeU16(method),
+    writeU16(0), // mod time
+    writeU16(0), // mod date
+    writeU32(crc),
+    writeU32(compressedSize),
+    writeU32(uncompressedSize),
+    writeU16(nameBuf.length),
+    writeU16(0), // extra length
+    nameBuf
+  ]);
+
+  const localOffset = 0;
+  const fileRecord = Buffer.concat([localHeader, payload]);
+
+  // Central directory header
+  const centralHeader = Buffer.concat([
+    writeU32(SIG_CENTRAL_DIR),
+    writeU16(20), // version made by
+    writeU16(20), // version needed
+    writeU16(0x0800), // flags (UTF-8)
+    writeU16(method),
+    writeU16(0),
+    writeU16(0),
+    writeU32(crc),
+    writeU32(compressedSize),
+    writeU32(uncompressedSize),
+    writeU16(nameBuf.length),
+    writeU16(0), // extra
+    writeU16(0), // comment
+    writeU16(0), // disk start
+    writeU16(0), // internal attrs
+    writeU32(0), // external attrs
+    writeU32(localOffset),
+    nameBuf
+  ]);
+
+  const centralDirOffset = fileRecord.length;
+  const centralDirSize = centralHeader.length;
+
+  // End of central directory
+  const end = Buffer.concat([
+    writeU32(SIG_END_CENTRAL_DIR),
+    writeU16(0), // disk number
+    writeU16(0), // disk with central
+    writeU16(1), // entries on this disk
+    writeU16(1), // total entries
+    writeU32(centralDirSize),
+    writeU32(centralDirOffset),
+    writeU16(0) // comment length
+  ]);
+
+  return Buffer.concat([fileRecord, centralHeader, end]);
+}
+
+/**
+ * Extract the single file from a ZIP.
+ * Enforces EXACTLY ONE entry named `dump.txt`.
+ */
+export function extractSingleFileZip(zipBuffer, requiredName = "dump.txt") {
+  if (!isZipBuffer(zipBuffer)) {
+    throw new Error("Not a ZIP buffer");
+  }
+
+  // Parse first local header
+  let off = 0;
+  const sig = u32(zipBuffer, off);
+  if (sig !== SIG_LOCAL_FILE) throw new Error("ZIP missing local file header");
+  off += 4;
+
+  const versionNeeded = u16(zipBuffer, off); off += 2;
+  void versionNeeded;
+
+  const flags = u16(zipBuffer, off); off += 2;
+  const method = u16(zipBuffer, off); off += 2;
+  off += 2; // mod time
+  off += 2; // mod date
+  const crc = u32(zipBuffer, off); off += 4;
+  const compSize = u32(zipBuffer, off); off += 4;
+  const uncompSize = u32(zipBuffer, off); off += 4;
+  const nameLen = u16(zipBuffer, off); off += 2;
+  const extraLen = u16(zipBuffer, off); off += 2;
+
+  // We don't support data descriptors. If bit 3 is set, sizes/crc may be 0 here.
+  if (flags & 0x0008) {
+    throw new Error("ZIP uses data descriptor (unsupported)");
+  }
+
+  const name = zipBuffer.slice(off, off + nameLen).toString("utf8");
+  off += nameLen;
+  off += extraLen;
+
+  if (name !== requiredName) {
+    throw new Error(`ZIP entry must be ${requiredName}`);
+  }
+
+  const dataStart = off;
+  const dataEnd = dataStart + compSize;
+  if (dataEnd > zipBuffer.length) {
+    throw new Error("ZIP entry data out of bounds");
+  }
+
+  let fileData = zipBuffer.slice(dataStart, dataEnd);
+  off = dataEnd;
+
+  // Ensure there is not a second local header before central directory
+  // (multipart zips forbidden)
+  for (let scan = off; scan + 4 <= zipBuffer.length; scan++) {
+    const s = zipBuffer.readUInt32LE(scan);
+    if (s === SIG_LOCAL_FILE) {
+      throw new Error("ZIP contains multiple entries (forbidden)");
+    }
+    if (s === SIG_CENTRAL_DIR || s === SIG_END_CENTRAL_DIR) {
+      break;
+    }
+  }
+
+  if (method === 0) {
+    // stored
+    if (fileData.length !== uncompSize) {
+      throw new Error("ZIP stored size mismatch");
+    }
+  } else if (method === 8) {
+    // deflate
+    fileData = zlib.inflateRawSync(fileData);
+    if (fileData.length !== uncompSize) {
+      throw new Error("ZIP inflate size mismatch");
+    }
+  } else {
+    throw new Error(`Unsupported ZIP compression method: ${method}`);
+  }
+
+  const computed = crc32(fileData);
+  if ((computed >>> 0) !== (crc >>> 0)) {
+    throw new Error("ZIP CRC32 mismatch");
+  }
+
+  return { name, data: fileData };
+}
--- a/zip-util.js
+++ b/zip-util.js
@@ -0,0 +1,228 @@
+import zlib from "zlib";
+
+// Minimal ZIP (PKZIP) utilities with zero dependencies.
+// Supports reading/writing a ZIP containing exactly one file.
+
+const SIG_LOCAL_FILE = 0x04034b50;
+const SIG_CENTRAL_DIR = 0x02014b50;
+const SIG_END_CENTRAL_DIR = 0x06054b50;
+
+function u16(buf, off) {
+  return buf.readUInt16LE(off);
+}
+
+function u32(buf, off) {
+  return buf.readUInt32LE(off);
+}
+
+function writeU16(n) {
+  const b = Buffer.alloc(2);
+  b.writeUInt16LE(n >>> 0, 0);
+  return b;
+}
+
+function writeU32(n) {
+  const b = Buffer.alloc(4);
+  b.writeUInt32LE(n >>> 0, 0);
+  return b;
+}
+
+// CRC32 implementation (table-driven)
+let CRC32_TABLE = null;
+
+function crc32Table() {
+  if (CRC32_TABLE) return CRC32_TABLE;
+  const table = new Uint32Array(256);
+  for (let i = 0; i < 256; i++) {
+    let c = i;
+    for (let k = 0; k < 8; k++) {
+      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
+    }
+    table[i] = c >>> 0;
+  }
+  CRC32_TABLE = table;
+  return table;
+}
+
+export function crc32(buf) {
+  const table = crc32Table();
+  let c = 0xffffffff;
+  for (let i = 0; i < buf.length; i++) {
+    c = table[(c ^ buf[i]) & 0xff] ^ (c >>> 8);
+  }
+  return (c ^ 0xffffffff) >>> 0;
+}
+
+function isZipBuffer(buf) {
+  return Buffer.isBuffer(buf) && buf.length >= 4 && buf.readUInt32LE(0) === 0x04034b50;
+}
+
+/**
+ * Create a ZIP buffer that contains EXACTLY one file.
+ *
+ * - No data descriptor
+ * - No encryption
+ * - UTF-8 filename flag set
+ */
+export function createSingleFileZip(filename, data, options = {}) {
+  if (typeof filename !== "string" || filename.length === 0) {
+    throw new Error("ZIP filename must be a non-empty string");
+  }
+  if (!Buffer.isBuffer(data)) {
+    throw new Error("ZIP data must be a Buffer");
+  }
+
+  const compress = options.compress !== false;
+  const nameBuf = Buffer.from(filename, "utf8");
+
+  const crc = crc32(data);
+  const uncompressedSize = data.length;
+  const method = compress ? 8 : 0; // 8 = deflate, 0 = store
+
+  const payload = compress ? zlib.deflateRawSync(data) : data;
+  const compressedSize = payload.length;
+
+  // Local file header
+  // https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
+  const localHeader = Buffer.concat([
+    writeU32(SIG_LOCAL_FILE),
+    writeU16(20), // version needed
+    writeU16(0x0800), // general purpose bit flag (UTF-8)
+    writeU16(method),
+    writeU16(0), // mod time
+    writeU16(0), // mod date
+    writeU32(crc),
+    writeU32(compressedSize),
+    writeU32(uncompressedSize),
+    writeU16(nameBuf.length),
+    writeU16(0), // extra length
+    nameBuf
+  ]);
+
+  const localOffset = 0;
+  const fileRecord = Buffer.concat([localHeader, payload]);
+
+  // Central directory header
+  const centralHeader = Buffer.concat([
+    writeU32(SIG_CENTRAL_DIR),
+    writeU16(20), // version made by
+    writeU16(20), // version needed
+    writeU16(0x0800), // flags (UTF-8)
+    writeU16(method),
+    writeU16(0),
+    writeU16(0),
+    writeU32(crc),
+    writeU32(compressedSize),
+    writeU32(uncompressedSize),
+    writeU16(nameBuf.length),
+    writeU16(0), // extra
+    writeU16(0), // comment
+    writeU16(0), // disk start
+    writeU16(0), // internal attrs
+    writeU32(0), // external attrs
+    writeU32(localOffset),
+    nameBuf
+  ]);
+
+  const centralDirOffset = fileRecord.length;
+  const centralDirSize = centralHeader.length;
+
+  // End of central directory
+  const end = Buffer.concat([
+    writeU32(SIG_END_CENTRAL_DIR),
+    writeU16(0), // disk number
+    writeU16(0), // disk with central
+    writeU16(1), // entries on this disk
+    writeU16(1), // total entries
+    writeU32(centralDirSize),
+    writeU32(centralDirOffset),
+    writeU16(0) // comment length
+  ]);
+
+  return Buffer.concat([fileRecord, centralHeader, end]);
+}
+
+/**
+ * Extract the single file from a ZIP.
+ * Enforces EXACTLY ONE entry named `dump.txt`.
+ */
+export function extractSingleFileZip(zipBuffer, requiredName = "dump.txt") {
+  if (!isZipBuffer(zipBuffer)) {
+    throw new Error("Not a ZIP buffer");
+  }
+
+  // Parse first local header
+  let off = 0;
+  const sig = u32(zipBuffer, off);
+  if (sig !== SIG_LOCAL_FILE) throw new Error("ZIP missing local file header");
+  off += 4;
+
+  const versionNeeded = u16(zipBuffer, off); off += 2;
+  void versionNeeded;
+
+  const flags = u16(zipBuffer, off); off += 2;
+  const method = u16(zipBuffer, off); off += 2;
+  off += 2; // mod time
+  off += 2; // mod date
+  const crc = u32(zipBuffer, off); off += 4;
+  const compSize = u32(zipBuffer, off); off += 4;
+  const uncompSize = u32(zipBuffer, off); off += 4;
+  const nameLen = u16(zipBuffer, off); off += 2;
+  const extraLen = u16(zipBuffer, off); off += 2;
+
+  // We don't support data descriptors. If bit 3 is set, sizes/crc may be 0 here.
+  if (flags & 0x0008) {
+    throw new Error("ZIP uses data descriptor (unsupported)");
+  }
+
+  const name = zipBuffer.slice(off, off + nameLen).toString("utf8");
+  off += nameLen;
+  off += extraLen;
+
+  if (name !== requiredName) {
+    throw new Error(`ZIP entry must be ${requiredName}`);
+  }
+
+  const dataStart = off;
+  const dataEnd = dataStart + compSize;
+  if (dataEnd > zipBuffer.length) {
+    throw new Error("ZIP entry data out of bounds");
+  }
+
+  let fileData = zipBuffer.slice(dataStart, dataEnd);
+  off = dataEnd;
+
+  // Ensure there is not a second local header before central directory
+  // (multipart zips forbidden)
+  for (let scan = off; scan + 4 <= zipBuffer.length; scan++) {
+    const s = zipBuffer.readUInt32LE(scan);
+    if (s === SIG_LOCAL_FILE) {
+      throw new Error("ZIP contains multiple entries (forbidden)");
+    }
+    if (s === SIG_CENTRAL_DIR || s === SIG_END_CENTRAL_DIR) {
+      break;
+    }
+  }
+
+  if (method === 0) {
+    // stored
+    if (fileData.length !== uncompSize) {
+      throw new Error("ZIP stored size mismatch");
+    }
+  } else if (method === 8) {
+    // deflate
+    fileData = zlib.inflateRawSync(fileData);
+    if (fileData.length !== uncompSize) {
+      throw new Error("ZIP inflate size mismatch");
+    }
+  } else {
+    throw new Error(`Unsupported ZIP compression method: ${method}`);
+  }
+
+  const computed = crc32(fileData);
+  if ((computed >>> 0) !== (crc >>> 0)) {
+    throw new Error("ZIP CRC32 mismatch");
+  }
+
+  return { name, data: fileData };
+}
