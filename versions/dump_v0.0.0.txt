---.env---
SCAN_N_BLOCKS=100
DB_PATH=online.sqlite
OUTPUT_PATH=runOutput.txt
SCAN_CMD=node safe_scan.js
SCAN_N_BLOCKS=100

---iterateBlocks.js---
'use strict';

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

/**
 * iterateBlocks(db, filePath, opts)
 *
 * Randomly iterates over lines in filePath WITHOUT repeats until exhausted,
 * then starts a new cycle. State is persisted in SQLite.
 *
 * Adds per-run tagging: each selected line is recorded in line_picker_picks
 * with run_id + namespace + file_id + line_index + line_text + picked_at.
 *
 * Uses a line-offset index for speed and low memory usage.
 *
 * opts:
 * - namespace: string (default: basename(filePath))
 * - ignoreBlank: boolean (default true)
 * - maxLineBytes: integer (default 8192)
 * - runId: string (optional, recommended) run identifier used for tagging
 *          If omitted, a run id is auto-generated and exposed via api.runId.
 *
 * Returned object:
 * - runId: string
 * - next(): Promise<string>
 * - nextN(n): Promise<string[]>
 * - nextMeta(): Promise<{text,lineIndex,startByte,endByte}>
 * - nextMetaN(n): Promise<Array<{text,lineIndex,startByte,endByte}>>
 * - info(): Promise<object>
 */

async function iterateBlocks(db, filePath, opts = {}) {
  const absFile = path.resolve(filePath);
  const namespace = opts.namespace || path.basename(absFile);
  const ignoreBlank = opts.ignoreBlank !== false;
  const maxLineBytes = Number.isInteger(opts.maxLineBytes) ? opts.maxLineBytes : 8192;

  // Per-run tag (stable identifier you pass from your main script)
  const runId = String(opts.runId || makeRunId());

  await ensureTables(db);

  // Build line-offset index
  const { meta, index } = buildLineIndex(absFile, { ignoreBlank });

  if (index.count === 0) {
    throw new Error(`File contains no usable lines: ${absFile}`);
  }

  const fileId = await upsertFile(db, meta);

  // Ensure state row exists
  await ensureStateRow(db, namespace, fileId, index.count);

  async function next() {
    const arr = await nextN(1);
    return arr[0];
  }

  async function nextN(n) {
    const metas = await nextMetaN(n);
    return metas.map((m) => m.text);
  }

  async function nextMeta() {
    const arr = await nextMetaN(1);
    return arr[0];
  }

  async function nextMetaN(n) {
    if (!Number.isInteger(n) || n <= 0) {
      throw new Error('nextMetaN(n): n must be a positive integer');
    }

    // Transaction ensures: (1) state mutation is consistent, (2) picks logging matches the state update.
    await exec(db, 'BEGIN IMMEDIATE;');
    try {
      let state = await getState(db, namespace, fileId);
      let remaining = safeParseJsonArray(state?.remaining_json);

      // Reset if exhausted or mismatch
      if (!remaining || remaining.length === 0 || state.total !== index.count) {
        remaining = freshRemaining(index.count);
        // New cycle marker
        await setCycle(db, namespace, fileId, Date.now(), index.count, remaining);
      }

      const take = Math.min(n, remaining.length);
      const pickedIdx = new Array(take);

      // Random pick without replacement (swap-pop)
      for (let i = 0; i < take; i++) {
        const r = crypto.randomInt(0, remaining.length);
        pickedIdx[i] = remaining[r];
        const last = remaining.pop();
        if (r < remaining.length) remaining[r] = last;
      }

      // Persist remaining for this cycle
      await writeRemaining(db, namespace, fileId, index.count, remaining);

      // Read selected lines by offset (outside DB but inside txn is fine; small reads)
      const pickedMeta = pickedIdx.map((li) => {
        const startByte = index.starts[li];
        const endByte = index.ends[li];
        const text = readLineSlice(absFile, startByte, endByte, maxLineBytes);
        return { text, lineIndex: li, startByte, endByte };
      });

      // Per-run tagging: log picks
      const ts = nowSec();
      for (let i = 0; i < take; i++) {
        await logPick(db, {
          runId,
          namespace,
          fileId,
          lineIndex: pickedMeta[i].lineIndex,
          lineText: pickedMeta[i].text,
          pickedAt: ts,
        });
      }

      await exec(db, 'COMMIT;');
      return pickedMeta;
    } catch (e) {
      await exec(db, 'ROLLBACK;').catch(() => {});
      throw e;
    }
  }

  async function info() {
    const state = await getState(db, namespace, fileId);
    const remaining = safeParseJsonArray(state?.remaining_json) || [];
    return {
      runId,
      namespace,
      file: absFile,
      total_lines: index.count,
      remaining_in_cycle: remaining.length,
      cycle: state?.cycle ?? null,
      last_updated_at: state?.updated_at ?? null,
    };
  }

  return { runId, next, nextN, nextMeta, nextMetaN, info };
}

/* ============================================================================
   LINE OFFSET INDEX
   ============================================================================ */

function buildLineIndex(filePath, { ignoreBlank }) {
  const st = fs.statSync(filePath);
  const fd = fs.openSync(filePath, 'r');

  try {
    const CHUNK = 1 << 16; // 64KB
    const buf = Buffer.allocUnsafe(CHUNK);

    const starts = [];
    const ends = [];

    let filePos = 0;
    let lineStart = 0;
    let hasNonWs = false;
    let lastCR = false;

    function isWs(b) {
      // space, tab, CR
      return b === 0x20 || b === 0x09 || b === 0x0d;
    }

    while (true) {
      const n = fs.readSync(fd, buf, 0, CHUNK, filePos);
      if (n <= 0) break;

      for (let i = 0; i < n; i++) {
        const b = buf[i];

        if (ignoreBlank && b !== 0x0a && !isWs(b)) hasNonWs = true;

        if (b === 0x0a) { // '\n'
          const end = (filePos + i) - (lastCR ? 1 : 0);
          if (!ignoreBlank || hasNonWs) {
            starts.push(lineStart);
            ends.push(end);
          }
          lineStart = filePos + i + 1;
          hasNonWs = false;
          lastCR = false;
        } else {
          lastCR = b === 0x0d;
        }
      }

      filePos += n;
    }

    // last line if no trailing newline
    if (lineStart < st.size) {
      if (!ignoreBlank || hasNonWs) {
        starts.push(lineStart);
        ends.push(st.size);
      }
    }

    return {
      meta: {
        path: filePath,
        mtimeMs: Math.floor(st.mtimeMs),
        sizeBytes: st.size,
        lineCount: starts.length,
      },
      index: {
        starts,
        ends,
        count: starts.length,
      },
    };
  } finally {
    fs.closeSync(fd);
  }
}

function readLineSlice(filePath, start, end, maxBytes) {
  const rawLen = end - start;
  if (rawLen < 0) throw new Error('Invalid line slice');

  const len = Math.min(rawLen, maxBytes);
  const fd = fs.openSync(filePath, 'r');
  try {
    const buf = Buffer.allocUnsafe(len);
    const n = fs.readSync(fd, buf, 0, len, start);
    let s = buf.slice(0, n).toString('utf8').trim();
    if (rawLen > maxBytes) s += '…';
    return s;
  } finally {
    fs.closeSync(fd);
  }
}

/* ============================================================================
   SQLITE STATE + PER-RUN PICK LOGGING
   ============================================================================ */

async function ensureTables(db) {
  await exec(db, `
    CREATE TABLE IF NOT EXISTS line_picker_files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      path TEXT UNIQUE,
      mtime_ms INTEGER,
      size_bytes INTEGER,
      line_count INTEGER,
      updated_at INTEGER
    );
  `);

  await exec(db, `
    CREATE TABLE IF NOT EXISTS line_picker_state (
      namespace TEXT,
      file_id INTEGER,
      cycle INTEGER,
      total INTEGER,
      remaining_json TEXT,
      updated_at INTEGER,
      PRIMARY KEY (namespace, file_id)
    );
  `);

  await exec(db, `
    CREATE TABLE IF NOT EXISTS line_picker_picks (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      run_id TEXT NOT NULL,
      namespace TEXT NOT NULL,
      file_id INTEGER NOT NULL,
      line_index INTEGER NOT NULL,
      line_text TEXT NOT NULL,
      picked_at INTEGER NOT NULL
    );
  `);

  await exec(db, `CREATE INDEX IF NOT EXISTS idx_line_picker_picks_run ON line_picker_picks(run_id);`);
  await exec(db, `CREATE INDEX IF NOT EXISTS idx_line_picker_picks_ns ON line_picker_picks(namespace, file_id);`);
  await exec(db, `CREATE INDEX IF NOT EXISTS idx_line_picker_picks_time ON line_picker_picks(picked_at);`);
}

async function upsertFile(db, meta) {
  await exec(db, `
    INSERT INTO line_picker_files(path, mtime_ms, size_bytes, line_count, updated_at)
    VALUES(?,?,?,?,?)
    ON CONFLICT(path) DO UPDATE SET
      mtime_ms=excluded.mtime_ms,
      size_bytes=excluded.size_bytes,
      line_count=excluded.line_count,
      updated_at=excluded.updated_at;
  `, [meta.path, meta.mtimeMs, meta.sizeBytes, meta.lineCount, nowSec()]);

  const row = await get(db, `SELECT id FROM line_picker_files WHERE path=?`, [meta.path]);
  return row.id;
}

async function ensureStateRow(db, namespace, fileId, total) {
  const exists = await get(db, `
    SELECT 1 FROM line_picker_state WHERE namespace=? AND file_id=?
  `, [namespace, fileId]);

  if (exists) return;

  const remaining = freshRemaining(total);
  await exec(db, `
    INSERT INTO line_picker_state(namespace, file_id, cycle, total, remaining_json, updated_at)
    VALUES(?,?,?,?,?,?)
  `, [namespace, fileId, Date.now(), total, JSON.stringify(remaining), nowSec()]);
}

async function getState(db, namespace, fileId) {
  return get(db, `
    SELECT cycle, total, remaining_json, updated_at
    FROM line_picker_state
    WHERE namespace=? AND file_id=?
  `, [namespace, fileId]);
}

async function setCycle(db, namespace, fileId, cycleMs, total, remaining) {
  await exec(db, `
    UPDATE line_picker_state
    SET cycle=?, total=?, remaining_json=?, updated_at=?
    WHERE namespace=? AND file_id=?
  `, [cycleMs, total, JSON.stringify(remaining), nowSec(), namespace, fileId]);
}

async function writeRemaining(db, namespace, fileId, total, remaining) {
  await exec(db, `
    UPDATE line_picker_state
    SET total=?, remaining_json=?, updated_at=?
    WHERE namespace=? AND file_id=?
  `, [total, JSON.stringify(remaining), nowSec(), namespace, fileId]);
}

async function logPick(db, { runId, namespace, fileId, lineIndex, lineText, pickedAt }) {
  await exec(db, `
    INSERT INTO line_picker_picks(run_id, namespace, file_id, line_index, line_text, picked_at)
    VALUES(?,?,?,?,?,?)
  `, [runId, namespace, fileId, lineIndex, lineText, pickedAt]);
}

/* ============================================================================
   HELPERS
   ============================================================================ */

function freshRemaining(total) {
  const arr = Array.from({ length: total }, (_, i) => i);
  for (let i = arr.length - 1; i > 0; i--) {
    const j = crypto.randomInt(0, i + 1);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function safeParseJsonArray(s) {
  try {
    const v = JSON.parse(s);
    return Array.isArray(v) ? v : null;
  } catch {
    return null;
  }
}

function nowSec() {
  return Math.floor(Date.now() / 1000);
}

function makeRunId() {
  // run_YYYYMMDD_HHMMSS_rand
  const d = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  const stamp =
    `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_` +
    `${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  const rand = crypto.randomBytes(3).toString('hex');
  return `run_${stamp}_${rand}`;
}

/* ============================================================================

   sqlite3 promise wrappers

   ============================================================================ */

function exec(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.run(sql, params, function (err) {
      if (err) reject(err);
      else resolve(this);
    });
  });
}

function get(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.get(sql, params, function (err, row) {
      if (err) reject(err);
      else resolve(row);
    });
  });
}

module.exports = { iterateBlocks };

---public/css/terminal.css---
/* --- public/css/terminal.css --- */
/* :contentReference[oaicite:1]{index=1} */
:root{
  --bg:#050611;
  --panel:#070a1b;
  --panel2:#040615;
  --line:rgba(255,255,255,.12);
  --text:#ecffff;
  --muted:#a9c7d6;

  --neon:#2dffdf;
  --neon2:#ff2df7;
  --neon3:#2dff7a;

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
}

@property --btnHue { syntax:'<angle>'; inherits:true; initial-value:0deg; }
@property --gridHueA { syntax:'<angle>'; inherits:true; initial-value:0deg; }
@property --gridHueB { syntax:'<angle>'; inherits:true; initial-value:0deg; }
@property --gridHueC { syntax:'<angle>'; inherits:true; initial-value:0deg; }

*{ box-sizing:border-box; }

body{
  margin:0;
  background:
    radial-gradient(1200px 800px at 20% -10%, rgba(45,255,223,.18), transparent 55%),
    radial-gradient(1000px 700px at 110% 10%, rgba(255,45,247,.14), transparent 55%),
    radial-gradient(900px 600px at 40% 110%, rgba(45,255,122,.10), transparent 60%),
    linear-gradient(180deg, #02030c, #06071a 45%, #02030c);
  color:var(--text);
  font-family:var(--sans);
  overflow-x:hidden;

  animation: btnHueDrift 18s linear infinite;
}

/* ✅ On initial page load, prevent any “loading animation” (pulses) */
body.noPulse .dot,
body.noPulse .gridPulse:before,
body.noPulse .gridPulse:after,
body.noPulse .gridPulse .laser3{
  animation: none !important;
}

@keyframes btnHueDrift{
  0%   { --btnHue: 0deg; }
  50%  { --btnHue: 42deg; }
  100% { --btnHue: 0deg; }
}

/* ---------------------------------------------------------------
   THREE ROTATING LASER GRIDS
--------------------------------------------------------------- */

body:before,
body:after,
.laser3{
  content:"";
  position:fixed;
  inset:-26%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.24;
  filter: blur(.25px);
  z-index:-2;
  will-change: transform, filter, opacity;
}

body:before{
  transform: rotate(14deg);
  background:
    linear-gradient(90deg, rgba(45,255,223,.40) 1px, transparent 1px) 0 0 / 66px 66px,
    linear-gradient(0deg,  rgba(45,255,223,.22) 1px, transparent 1px) 0 0 / 66px 66px,
    radial-gradient(900px 500px at 60% 50%, rgba(45,255,223,.06), transparent 62%);
  animation: gridMoveDiagUp 20s linear infinite, gridHueA 23s linear infinite;
}

body:after{
  transform: rotate(-18deg);
  background:
    linear-gradient(90deg, rgba(255,45,247,.38) 1px, transparent 1px) 0 0 / 74px 74px,
    linear-gradient(0deg,  rgba(255,45,247,.20) 1px, transparent 1px) 0 0 / 74px 74px,
    radial-gradient(900px 500px at 45% 55%, rgba(255,45,247,.05), transparent 62%);
  animation: gridMoveDiagDown 24s linear infinite, gridHueB 29s linear infinite;
}

.laser3{
  transform: rotate(38deg);
  background:
    linear-gradient(90deg, rgba(45,255,122,.32) 1px, transparent 1px) 0 0 / 92px 92px,
    linear-gradient(0deg,  rgba(45,255,122,.18) 1px, transparent 1px) 0 0 / 92px 92px,
    radial-gradient(1100px 520px at 55% 45%, rgba(255,255,255,.05), transparent 62%);
  opacity:.18;
  animation: gridMoveSlowSpin 30s linear infinite, gridHueC 31s linear infinite;
}

@keyframes gridMoveDiagUp{
  0%   { transform: rotate(14deg) translate3d(0,0,0); }
  100% { transform: rotate(14deg) translate3d(-320px, -320px, 0); }
}
@keyframes gridMoveDiagDown{
  0%   { transform: rotate(-18deg) translate3d(0,0,0); }
  100% { transform: rotate(-18deg) translate3d(300px, 300px, 0); }
}
@keyframes gridMoveSlowSpin{
  0%   { transform: rotate(38deg) translate3d(0,0,0); }
  50%  { transform: rotate(52deg) translate3d(-140px, 130px, 0); }
  100% { transform: rotate(38deg) translate3d(0,0,0); }
}

@keyframes gridHueA{
  0%   { --gridHueA: 0deg; filter: hue-rotate(var(--gridHueA)) blur(.25px); }
  50%  { --gridHueA: 62deg; filter: hue-rotate(var(--gridHueA)) blur(.25px); }
  100% { --gridHueA: 0deg; filter: hue-rotate(var(--gridHueA)) blur(.25px); }
}
@keyframes gridHueB{
  0%   { --gridHueB: 0deg; filter: hue-rotate(var(--gridHueB)) blur(.25px); }
  50%  { --gridHueB: 48deg; filter: hue-rotate(var(--gridHueB)) blur(.25px); }
  100% { --gridHueB: 0deg; filter: hue-rotate(var(--gridHueB)) blur(.25px); }
}
@keyframes gridHueC{
  0%   { --gridHueC: 0deg; filter: hue-rotate(var(--gridHueC)) blur(.25px); }
  50%  { --gridHueC: 70deg; filter: hue-rotate(var(--gridHueC)) blur(.25px); }
  100% { --gridHueC: 0deg; filter: hue-rotate(var(--gridHueC)) blur(.25px); }
}

.scanlinesOverlay{
  position:fixed;
  inset:0;
  pointer-events:none;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255,255,255,.035),
    rgba(255,255,255,.035) 1px,
    transparent 2px,
    transparent 6px
  );
  mix-blend-mode: overlay;
  opacity:.24;
  z-index:-1;
}

body.gridPulse:before,
body.gridPulse:after,
body.gridPulse .laser3{
  opacity:.92 !important;
  filter:
    blur(.30px)
    drop-shadow(0 0 26px rgba(45,255,223,.95))
    drop-shadow(0 0 44px rgba(255,45,247,.75))
    drop-shadow(0 0 38px rgba(45,255,122,.55)) !important;
}

/* ---------------------------------------------------------------
   FUZZ overlay (unchanged)
--------------------------------------------------------------- */

.fuzzOverlay{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:999;
  opacity:0;
  background:
    repeating-linear-gradient(90deg,
      rgba(255,255,255,.0) 0px,
      rgba(255,255,255,.0) 18px,
      rgba(255,255,255,.28) 19px,
      rgba(255,255,255,.0) 26px),
    repeating-linear-gradient(0deg,
      rgba(0,0,0,.0) 0px,
      rgba(0,0,0,.0) 14px,
      rgba(0,0,0,.24) 15px,
      rgba(0,0,0,.0) 22px),
    repeating-linear-gradient(0deg,
      rgba(255,255,255,.12) 0px,
      rgba(255,255,255,.12) 1px,
      rgba(0,0,0,.10) 2px,
      rgba(0,0,0,.10) 4px),
    radial-gradient(closest-side at 18% 28%, rgba(255,255,255,.70), transparent 62%),
    radial-gradient(closest-side at 68% 34%, rgba(0,0,0,.70), transparent 62%),
    radial-gradient(closest-side at 40% 72%, rgba(255,255,255,.55), transparent 66%),
    radial-gradient(closest-side at 82% 78%, rgba(0,0,0,.55), transparent 66%),
    repeating-radial-gradient(circle at 10% 20%,
      rgba(255,255,255,.18) 0 1px,
      rgba(0,0,0,.18) 1px 2px,
      transparent 2px 6px);
  mix-blend-mode: overlay;
  filter: contrast(260%) brightness(140%);
  transform: translateZ(0);
  transition: opacity 70ms linear;
}

body.fuzzOn .fuzzOverlay{
  opacity: 1;
  animation:
    fuzzDisconnect 4s linear 1,
    fuzzJitter 120ms linear infinite,
    fuzzBands 220ms steps(2,end) infinite,
    fuzzBlocks 160ms steps(2,end) infinite;
  box-shadow:
    inset 0 0 80px rgba(255,255,255,.35),
    inset 0 0 120px rgba(0,0,0,.40);
}

@keyframes fuzzDisconnect{
  0%   { opacity: .0; }
  6%   { opacity: 1; }
  65%  { opacity: 1; }
  85%  { opacity: .55; }
  100% { opacity: 0; }
}
@keyframes fuzzJitter{
  0%   { transform: translate3d(0,0,0) scale(1); }
  15%  { transform: translate3d(-2px,1px,0) scale(1.01); }
  30%  { transform: translate3d(3px,-1px,0) scale(.995); }
  45%  { transform: translate3d(-1px,-3px,0) scale(1.01); }
  60%  { transform: translate3d(2px,2px,0) scale(.99); }
  75%  { transform: translate3d(-3px,1px,0) scale(1.015); }
  90%  { transform: translate3d(1px,-2px,0) scale(.99); }
  100% { transform: translate3d(0,0,0) scale(1); }
}
@keyframes fuzzBands{
  0%   { filter: contrast(260%) brightness(135%); }
  20%  { filter: contrast(320%) brightness(165%); }
  40%  { filter: contrast(240%) brightness(125%); }
  60%  { filter: contrast(360%) brightness(180%); }
  80%  { filter: contrast(260%) brightness(140%); }
  100% { filter: contrast(320%) brightness(170%); }
}
@keyframes fuzzBlocks{
  0%   { background-position: 0 0, 0 0, 0 0, 0 0, 0 0, 0 0, 0 0, 0 0; }
  20%  { background-position: 40px 12px, -18px 26px, 0 18px, 18px 0, -30px 14px, 24px -10px, -12px 20px, 0 0; }
  40%  { background-position: -22px 30px, 26px -18px, 0 0, -10px 22px, 14px -24px, -34px 26px, 22px -8px, 0 0; }
  60%  { background-position: 12px -26px, -30px 10px, 0 24px, 26px -12px, -18px 30px, 10px -30px, -26px 12px, 0 0; }
  80%  { background-position: -34px 18px, 16px 34px, 0 12px, -24px 14px, 28px 10px, -14px 24px, 30px -18px, 0 0; }
  100% { background-position: 0 0, 0 0, 0 0, 0 0, 0 0, 0 0, 0 0, 0 0; }
}

/* ---------------------------------------------------------------
   HEADER / PILLS / PANELS / CONTROLS
--------------------------------------------------------------- */

header{
  position:sticky; top:0;
  z-index:20;
  padding:14px 14px 10px;
  background: linear-gradient(180deg, rgba(6,7,18,.94), rgba(6,7,18,.76));
  border-bottom:1px solid rgba(255,255,255,.12);
  backdrop-filter: blur(14px);
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
}

.title{
  display:flex; align-items:center; gap:12px;
  font-family:var(--mono);
  letter-spacing:.06em;
  text-shadow:
    0 0 18px rgba(45,255,223,.20),
    0 0 26px rgba(255,45,247,.12);
}

.dot{
  width:10px; height:10px; border-radius:50%;
  background:var(--neon);
  box-shadow:
    0 0 22px rgba(45,255,223,1),
    0 0 54px rgba(45,255,223,.55);
  animation:pulseDot 1.6s infinite ease-in-out;
}
@keyframes pulseDot{
  0%,100%{ transform:scale(1); opacity:.80; }
  50%{ transform:scale(1.7); opacity:1; }
}

.subtitle{ color:var(--muted); font-size:12px; margin-top:4px; font-family:var(--mono); }
.tcopy .tmain{ font-size:14px; }

.hdrTop{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
}

.hdrPills{
  display:flex;
  gap:10px;
  flex-wrap:nowrap;
  overflow-x:auto;
  padding:10px 0 2px;
  -webkit-overflow-scrolling: touch;
  scrollbar-width:none;
}
.hdrPills::-webkit-scrollbar{ display:none; }

.hdrMeta{
  margin-top: 6px;
  display:flex;
  justify-content:flex-end;
}

@media (min-width: 980px){
  .hdrPills{
    justify-content:flex-end;
    flex-wrap:wrap;
    overflow:visible;
    padding-top:2px;
  }
}

main{ padding:14px 14px 26px; }

.grid{
  display:grid;
  grid-template-columns: 520px 1fr;
  gap:14px;
  align-items:start;
}
@media (max-width: 1000px){
  .grid{ grid-template-columns: 1fr; }
}

.card{
  border:1px solid rgba(255,255,255,.16);
  background:
    radial-gradient(900px 260px at 20% -10%, rgba(45,255,223,.10), transparent 55%),
    radial-gradient(900px 260px at 110% 0%, rgba(255,45,247,.08), transparent 55%),
    linear-gradient(180deg, rgba(7,10,27,.96), rgba(3,4,14,.96));
  border-radius:16px;
  overflow:hidden;
  position:relative;
  backdrop-filter: blur(12px);
  isolation:isolate;
  box-shadow:
    0 18px 70px rgba(0,0,0,.68),
    0 0 0 1px rgba(0,0,0,.22) inset,
    0 0 26px rgba(45,255,223,.08),
    0 0 18px rgba(255,45,247,.06);
}

.cardHead{
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,.12);
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  font-family:var(--mono);
}

.tag{ font-size:12px; color:var(--muted); }
.meta{
  padding:12px 14px 8px;
  font-family:var(--mono);
  font-size:12px;
  color:var(--muted);
  line-height:1.55;
}
.mono{ font-family:var(--mono); }
.small{ font-size:11px; color:var(--muted); }
.right{ text-align:right; }

.pill{
  display:flex; gap:8px; align-items:center;
  border:1px solid rgba(45,255,223,.22);
  background: rgba(0,0,0,.30);
  border-radius:999px;
  padding:7px 9px;
  font-family:var(--mono);
  min-width: 150px;
  filter: hue-rotate(var(--btnHue));
  transition: box-shadow .12s ease, border-color .12s ease, transform .12s ease;
  box-shadow:
    0 0 0 1px rgba(0,0,0,.22) inset,
    0 0 18px rgba(45,255,223,.08);
}
.pill .k{ color:var(--muted); font-size:10px; }
.pill .v{
  font-size:13px;
  color:var(--text);
  text-shadow:
    0 0 10px rgba(45,255,223,.14),
    0 0 16px rgba(255,45,247,.10);
}
.pill.glow{
  border-color: rgba(45,255,223,.55);
  box-shadow:
    0 0 26px rgba(45,255,223,.22),
    0 0 50px rgba(45,255,223,.12);
}
.pill.pillPulse{
  border-color: rgba(45,255,223,.82);
  box-shadow:
    0 0 32px rgba(45,255,223,.42),
    0 0 64px rgba(255,45,247,.22);
  transform: translateY(-1px) scale(1.01);
}

.btnRow{
  display:flex; gap:10px; flex-wrap:wrap;
  padding: 10px 14px 14px;
}

/* ===========================
   BUTTON SYSTEM (DROP-IN CLASSES)
   =========================== */

button{
  appearance:none;
  border:1px solid rgba(45,255,223,.55);
  background: linear-gradient(180deg, rgba(45,255,223,.26), rgba(45,255,223,.08));
  color:var(--text);
  padding:9px 11px;
  border-radius:14px;
  font-family:var(--mono);
  cursor:pointer;
  transition: transform .10s ease, background .12s ease, box-shadow .12s ease, border-color .12s ease, filter .12s ease;
  box-shadow:
    0 0 0 1px rgba(0,0,0,.20) inset,
    0 10px 36px rgba(0,0,0,.44),
    0 0 18px rgba(45,255,223,.12);
  position:relative;
  overflow:hidden;
  filter: hue-rotate(var(--btnHue));
  text-shadow: 0 0 12px rgba(45,255,223,.16);
}
button:before{
  content:"";
  position:absolute;
  inset:-2px;
  background: radial-gradient(320px 90px at 30% 0%, rgba(255,255,255,.20), transparent 55%);
  opacity:.55;
  transform: translateY(-10px);
  pointer-events:none;
}
button:hover{
  transform: translateY(-1px);
  border-color: rgba(255,45,247,.55);
  box-shadow:
    0 0 36px rgba(255,45,247,.18),
    0 0 28px rgba(45,255,223,.22),
    0 12px 40px rgba(0,0,0,.52);
}
button:active{ transform: translateY(0px); }
button.btnPulse{
  box-shadow:
    0 0 40px rgba(45,255,223,.55),
    0 0 76px rgba(255,45,247,.28),
    0 12px 44px rgba(0,0,0,.55);
  border-color: rgba(45,255,223,.86);
}

/* Drop-in action classes */
.btn-ok{
  border-color: rgba(45,255,122,.62);
  background: linear-gradient(180deg, rgba(45,255,122,.30), rgba(45,255,122,.08));
  box-shadow:
    0 0 0 1px rgba(0,0,0,.20) inset,
    0 10px 36px rgba(0,0,0,.44),
    0 0 18px rgba(45,255,122,.16);
}
.btn-ok:hover{
  border-color: rgba(45,255,122,.95);
  background: linear-gradient(180deg, rgba(45,255,122,.36), rgba(45,255,223,.10));
  box-shadow:
    0 0 38px rgba(45,255,122,.24),
    0 0 28px rgba(45,255,223,.20),
    0 12px 40px rgba(0,0,0,.52);
}

.btn-warn{
  border-color: rgba(255,191,45,.62);
  background: linear-gradient(180deg, rgba(255,191,45,.28), rgba(255,191,45,.07));
  box-shadow:
    0 0 0 1px rgba(0,0,0,.20) inset,
    0 10px 36px rgba(0,0,0,.44),
    0 0 18px rgba(255,191,45,.14);
}
.btn-warn:hover{
  border-color: rgba(255,191,45,.95);
  background: linear-gradient(180deg, rgba(255,191,45,.34), rgba(255,45,247,.10));
  box-shadow:
    0 0 38px rgba(255,191,45,.22),
    0 0 26px rgba(255,45,247,.14),
    0 12px 40px rgba(0,0,0,.52);
}

.btn-danger{
  border-color: rgba(255,63,85,.72);
  background: linear-gradient(180deg, rgba(255,63,85,.28), rgba(255,63,85,.07));
  box-shadow:
    0 0 0 1px rgba(0,0,0,.20) inset,
    0 10px 36px rgba(0,0,0,.44),
    0 0 18px rgba(255,63,85,.16);
}
.btn-danger:hover{
  border-color: rgba(255,63,85,.98);
  background: linear-gradient(180deg, rgba(255,63,85,.34), rgba(255,45,247,.10));
  box-shadow:
    0 0 40px rgba(255,63,85,.26),
    0 0 28px rgba(255,45,247,.16),
    0 12px 40px rgba(0,0,0,.52);
}

.btn-run{
  border-color: rgba(45,255,223,.72);
  background: linear-gradient(180deg, rgba(45,255,223,.34), rgba(45,255,223,.10));
  box-shadow:
    0 0 0 1px rgba(0,0,0,.20) inset,
    0 10px 36px rgba(0,0,0,.44),
    0 0 22px rgba(45,255,223,.20);
}
.btn-run:hover{
  border-color: rgba(45,255,223,1);
  background: linear-gradient(180deg, rgba(45,255,223,.40), rgba(255,45,247,.10));
  box-shadow:
    0 0 46px rgba(45,255,223,.26),
    0 0 30px rgba(255,45,247,.16),
    0 12px 40px rgba(0,0,0,.52);
}

/* Slightly “neutral” */
.btn-neutral{
  border-color: rgba(255,255,255,.20);
  background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
  box-shadow:
    0 0 0 1px rgba(0,0,0,.24) inset,
    0 10px 36px rgba(0,0,0,.44);
}
.btn-neutral:hover{
  border-color: rgba(255,255,255,.34);
  background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(45,255,223,.06));
}

.sched{
  margin: 0 14px 14px;
  border: 1px solid rgba(255,255,255,.14);
  border-radius: 14px;
  background: rgba(0,0,0,.24);
  overflow:hidden;
  font-family: var(--mono);
  box-shadow: 0 0 0 1px rgba(0,0,0,.22) inset;
}
.schedHead{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding: 10px 12px;
  border-bottom:1px solid rgba(255,255,255,.12);
}
.schedBody{ padding: 10px 12px 12px; }
.sched .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-top:8px; }
.sched label{ color: var(--muted); font-size: 11px; }
.sched input{
  width: 140px;
  padding: 9px 10px;
  border-radius: 14px;
  border: 1px solid rgba(45,255,223,.40);
  background: rgba(0,0,0,.30);
  color: var(--text);
  font-family: var(--mono);
  box-shadow: 0 0 0 1px rgba(0,0,0,.22) inset, 0 0 16px rgba(45,255,223,.08);
}
.sched.isRunning{ opacity: .55; filter: grayscale(.15); }
.sched.isRunning button,
.sched.isRunning input{ pointer-events:none; }

.tableWrap{ padding: 10px 14px 14px; }
table{ width:100%; border-collapse: collapse; font-family:var(--mono); font-size:12px; }
th, td{
  padding:10px 8px;
  border-bottom:1px solid rgba(255,255,255,.07);
  white-space:nowrap;
  text-overflow:ellipsis;
  overflow:hidden;
  max-width: 220px;
}
th{
  color:var(--muted);
  font-weight:600;
  text-align:left;
  position:sticky;
  top:0;
  background: rgba(3,4,14,.94);
  backdrop-filter: blur(10px);
}
tr:hover td{ background: rgba(255,255,255,.05); }

/* -------------------- Online IPs row effects -------------------- */

tbody#rowsBody tr.ipRow{
  transition: background-color .18s ease, box-shadow .18s ease, transform .28s ease;
}

tr.ipRow.currentRun td{
  background: rgba(255,255,255,.040);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
}

tr.ipRow.prevRun td{
  background: rgba(255,255,255,.026);
}

body.runFresh tr.ipRow.currentRun td{
  background: rgba(255,255,255,.028);
}
body.runFresh tr.ipRow.prevRun td{
  background: rgba(255,255,255,.020);
}

/* New IP insertion: starts at 1.2x scale and settles into place */
tr.ipRow.newIp{
  transform: scale(1.2);
}
tr.ipRow.settle{
  transform: scale(1);
}

/* ONLY newly inserted row flashes green */
tr.ipRow.newIp td{
  animation: newIpGlowFade 1.05s ease-out 1;
}

@keyframes newIpGlowFade{
  0%{
    background: rgba(45,255,122,.16);
    box-shadow:
      inset 0 0 0 1px rgba(45,255,122,.32),
      0 0 18px rgba(45,255,122,.26),
      0 0 46px rgba(45,255,122,.16);
  }
  55%{
    background: rgba(45,255,122,.08);
    box-shadow:
      inset 0 0 0 1px rgba(45,255,122,.18),
      0 0 10px rgba(45,255,122,.14);
  }
  100%{
    background: rgba(255,255,255,.040);
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.04);
  }
}

body.runFresh tr.ipRow.newIp td{
  animation: newIpGlowFadeFresh 1.05s ease-out 1;
}
@keyframes newIpGlowFadeFresh{
  0%{
    background: rgba(45,255,122,.16);
    box-shadow:
      inset 0 0 0 1px rgba(45,255,122,.32),
      0 0 18px rgba(45,255,122,.26),
      0 0 46px rgba(45,255,122,.16);
  }
  55%{
    background: rgba(45,255,122,.08);
    box-shadow:
      inset 0 0 0 1px rgba(45,255,122,.18),
      0 0 10px rgba(45,255,122,.14);
  }
  100%{
    background: rgba(255,255,255,.028);
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.04);
  }
}

.consoleTop{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding: 10px 14px;
  border-bottom:1px solid rgba(255,255,255,.12);
  font-family:var(--mono);
}

.console{
  height: 360px;
  background: rgba(1,2,8,.94);
  border-top:1px solid rgba(255,255,255,.12);
  font-family:var(--mono);
  font-size:12px;
  color: #d6fff6;
  padding:12px 12px 14px;
  overflow:auto;
  position:relative;
  margin:0;
  text-shadow:
    0 0 16px rgba(45,255,223,.18),
    0 0 22px rgba(255,45,247,.10);
}

---public/js/dashboard.js---
/* --- public/js/dashboard.js --- */
/* :contentReference[oaicite:0]{index=0} */
(() => {
  'use strict';

  const el = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  const state = {
    tailKey: 'global',
    activeRun: null,
    lastRowsSig: '',
    schedule: null
  };

  let scheduleState = null;
  let firstEverAtSec = null;

  function fmtNum(n){
    if (n == null || Number.isNaN(Number(n))) return '—';
    return Number(n).toLocaleString('en-US');
  }

  function fmtTs(sec){
    if (!sec || !Number.isFinite(Number(sec))) return '—';
    const d = new Date(Number(sec) * 1000);
    return d.toISOString().replace('T',' ').replace('Z','Z');
  }

  function fmtMs(ms){
    if (ms == null || !Number.isFinite(Number(ms))) return '—';
    const s = Math.max(0, Math.floor(Number(ms)/1000));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return String(m).padStart(2,'0') + ':' + String(r).padStart(2,'0');
  }

  function setHeaderFacts(meta, block, firstEverSec){
    if (firstEverSec && Number.isFinite(Number(firstEverSec))) {
      if (firstEverAtSec == null) firstEverAtSec = Number(firstEverSec);
      else firstEverAtSec = Math.min(firstEverAtSec, Number(firstEverSec));
    }

    const lastBlock = block && block.ip_block ? block.ip_block : '—';
    const lastAt = meta && meta.created_at ? fmtTs(meta.created_at) : '—';
    const firstEver = firstEverAtSec ? fmtTs(firstEverAtSec) : '—';

    if (el('hLastBlock')) el('hLastBlock').textContent = lastBlock;
    if (el('hLastTime')) el('hLastTime').textContent = lastAt;
    if (el('hFirstEver')) el('hFirstEver').textContent = firstEver;
  }

  function setMeta(meta, block){
    if (!meta) {
      el('activeRunTag').textContent = 'no runs';
      el('mRun').textContent = '—';
      el('mCreated').textContent = '—';
      el('mPort').textContent = '—';
      el('mSource').textContent = '—';
      el('mBlock').textContent = '—';
      return;
    }

    el('activeRunTag').textContent = meta.run_table || '—';
    el('mRun').textContent = meta.run_table || '—';
    el('mCreated').textContent = fmtTs(meta.created_at);
    el('mPort').textContent = meta.port != null ? String(meta.port) : '—';
    el('mSource').textContent = meta.source || '—';
    el('mBlock').textContent = (block && block.ip_block) ? block.ip_block : '—';
  }

  function pulse(id){
    const x = el(id);
    if (!x) return;
    x.classList.remove('pillPulse');
    // force reflow
    void x.offsetWidth;
    x.classList.add('pillPulse');
    setTimeout(() => x.classList.remove('pillPulse'), 550);
  }

  function applyDbStats(stats){
    if (!stats) return;

    const prev = {
      unique: el('pUnique').textContent,
      total: el('pTotal').textContent,
      hot: el('pHot').textContent,
      first: el('pFirst').textContent,
      last: el('pLast').textContent
    };

    const next = {
      unique: fmtNum(stats.unique_ips),
      total: fmtNum(stats.total_observations),
      hot: fmtNum(stats.hot_unique_ips),
      first: fmtTs(stats.first_seen),
      last: fmtTs(stats.last_seen)
    };

    el('pUnique').textContent = next.unique;
    el('pTotal').textContent = next.total;
    el('pHot').textContent = next.hot;
    el('pFirst').textContent = next.first;
    el('pLast').textContent = next.last;

    if (prev.unique !== next.unique) pulse('pillUnique');
    if (prev.total !== next.total) pulse('pillTotal');
    if (prev.hot !== next.hot) pulse('pillHot');
    if (prev.first !== next.first) pulse('pillFirst');
    if (prev.last !== next.last) pulse('pillLast');
  }

  function rowSig(rows){
    if (!rows || !rows.length) return '';
    return rows.map(r => `${r.ip}|${r.last_seen}|${r.seen_count}|${r._run}`).join(';');
  }

  function renderRows(rows){
    const tb = el('rowsBody');
    if (!tb) return;

    const sig = rowSig(rows);
    if (sig === state.lastRowsSig) return;
    state.lastRowsSig = sig;

    const currentRun = state.activeRun;

    tb.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      tr.className = 'ipRow ' + ((r._run && currentRun && r._run === currentRun) ? 'currentRun' : 'prevRun');

      const td = (v) => {
        const x = document.createElement('td');
        x.textContent = v;
        return x;
      };

      tr.appendChild(td(r.ip || ''));
      tr.appendChild(td(r.port != null ? String(r.port) : ''));
      tr.appendChild(td(r.source || ''));
      tr.appendChild(td(fmtTs(r.first_seen)));
      tr.appendChild(td(fmtTs(r.last_seen)));
      tr.appendChild(td(fmtNum(r.seen_count)));

      tb.appendChild(tr);

      // new row animation: scale then settle
      if (r._isNew) {
        tr.classList.add('newIp');
        requestAnimationFrame(() => {
          setTimeout(() => tr.classList.add('settle'), 30);
          setTimeout(() => { tr.classList.remove('newIp'); tr.classList.remove('settle'); }, 1150);
        });
      }
    }
  }

  function appendConsole(text){
    if (!text) return;
    const c = el('console');
    if (!c) return;
    const atBottom = (c.scrollHeight - c.scrollTop - c.clientHeight) < 30;
    c.textContent += text;
    // cap (keep last ~160kb)
    if (c.textContent.length > 160000) {
      c.textContent = c.textContent.slice(-120000);
    }
    if (atBottom) c.scrollTop = c.scrollHeight;
  }

  function appendConsoleLine(line){
    const s = String(line ?? '');
    appendConsole(s.endsWith('\n') ? s : s + '\n');
  }

  async function pollTail(){
    try {
      const r = await fetch(`/api/tail?key=${encodeURIComponent(state.tailKey)}`);
      const j = await r.json();
      if (j && j.text) appendConsole(j.text);
      el('tailTag').textContent = j && j.source ? j.source : '—';
      el('lastUpdateTag').textContent = new Date().toISOString().replace('T',' ').replace('Z','Z');
    } catch {}
  }

  async function pollLatestRun(){
    try {
      const r = await fetch('/api/run/latest');
      const j = await r.json();
      if (!j || !j.meta) {
        state.activeRun = null;
        setMeta(null, null);
        setHeaderFacts(null, null, null);
        return;
      }

      state.activeRun = j.meta.run_table || null;

      // support either naming from server
      const firstEver =
        (j.meta && (j.meta.first_ever_created_at || j.meta.firstEverCreatedAt)) ||
        j.first_ever_created_at ||
        j.firstEverCreatedAt ||
        null;

      setMeta(j.meta, j.block || null);
      setHeaderFacts(j.meta, j.block || null, firstEver);

      // keep pills refreshing whenever we have an active run
      await pollDbStats();
      await pollRows();
    } catch {}
  }

  async function pollDbStats(){
    if (!state.activeRun) return;
    try {
      const r = await fetch(`/api/run/${encodeURIComponent(state.activeRun)}/stats`);
      const j = await r.json();
      applyDbStats(j);
    } catch {}
  }

  async function pollRows(){
    if (!state.activeRun) return;
    try {
      const r = await fetch(`/api/run/${encodeURIComponent(state.activeRun)}/rows?limit=50`);
      const j = await r.json();
      renderRows(Array.isArray(j) ? j : []);
      el('rowsTag').textContent = `${Array.isArray(j) ? j.length : 0} rows`;
    } catch {}
  }

  function updateScheduleUi(){
    const st = scheduleState || {};
    const armed = !!st.armed;
    el('schedState').textContent = armed ? 'ARMED' : 'DISARMED';

    if (armed && st.nextRunAtMs && Number.isFinite(Number(st.nextRunAtMs))) {
      const ms = Number(st.nextRunAtMs) - Date.now();
      el('countdown').textContent = fmtMs(ms);
    } else if (armed) {
      el('countdown').textContent = '—';
    } else {
      el('countdown').textContent = '—';
    }

    // lock form during run
    const schedCard = document.querySelector('.sched');
    if (schedCard) {
      if (st.running) schedCard.classList.add('isRunning');
      else schedCard.classList.remove('isRunning');
    }
  }

  async function fetchSchedule(reset){
    try {
      const r = await fetch(`/api/schedule/status${reset ? '?reset=1' : ''}`);
      const j = await r.json();
      scheduleState = j;
      updateScheduleUi();
    } catch {}
  }

  async function armSchedule(){
    const raw = (el('delayMin') && el('delayMin').value != null) ? String(el('delayMin').value) : '';
    const vMin = Number(raw);
    if (!Number.isFinite(vMin) || vMin <= 0) {
      el('schedState').textContent = 'ERR';
      appendConsoleLine(`[ui] invalid delay_minutes: "${raw}"`);
      return;
    }

    const delaySec = Math.max(1, Math.round(vMin * 60));

    try {
      const r = await fetch('/api/schedule/arm', {
        method: 'POST',
        headers: { 'content-type':'application/json' },
        body: JSON.stringify({ delaySec })
      });
      const j = await r.json().catch(() => ({}));
      if (!r.ok) {
        el('schedState').textContent = 'ERR';
        appendConsoleLine(`[ui] arm failed (${r.status}): ${j && j.error ? j.error : 'unknown error'}`);
        return;
      }
      scheduleState = j;
      updateScheduleUi();
      await fetchSchedule(true);
    } catch (e) {
      el('schedState').textContent = 'ERR';
      appendConsoleLine(`[ui] arm failed: ${String(e && e.message ? e.message : e)}`);
    }
  }

  async function disarmSchedule(){
    try {
      await fetch('/api/schedule/disarm', { method:'POST' });
      await fetchSchedule(true);
    } catch {}
  }

  async function runNow(){
    try {
      await fetch('/api/schedule/run-now', { method:'POST' });
      await fetchSchedule(true);
    } catch {}
  }

  // ✅ Styling-only: add drop-in action classes by ID (no behavior changes)
  function applyActionButtonClasses(){
    const armBtn =
      (el('armBtn')) ||
      (el('btnArm')) ||
      (document.querySelector('#schedForm button[type="submit"]')) ||
      null;

    const disarmBtn = el('disarmBtn') || el('btnCancel') || null;
    const runNowBtn = el('runNowBtn') || el('btnRunNow') || null;

    if (armBtn) armBtn.classList.add('btn-ok');
    if (disarmBtn) disarmBtn.classList.add('btn-danger');
    if (runNowBtn) runNowBtn.classList.add('btn-run');
  }

  function init(){
    // remove noPulse once JS is live (prevents initial flash animation)
    document.body.classList.remove('noPulse');

    // apply action button styling classes
    applyActionButtonClasses();

    el('schedForm').addEventListener('submit', (e) => {
      e.preventDefault();
      armSchedule();
    });
    el('disarmBtn').addEventListener('click', disarmSchedule);
    el('runNowBtn').addEventListener('click', runNow);

    // polls
    setInterval(pollTail, 1000);
    setInterval(() => fetchSchedule(false), 1000);
    setInterval(pollLatestRun, 2000);

    // kick
    pollTail();
    fetchSchedule(true);
    pollLatestRun();
  }

  init();
})();

---safe_scan.js---
#!/usr/bin/env node
'use strict';

/**
README — Streaming IP Ingest → SQLite (per-run tables)

Plain-text logging:
- All script logs are appended to ./runOutput.txt
- Each console line = one log line
- No JSON, no stdout interference
*/

//
// CONFIGURATION
//

const DB_PATH = './online.sqlite';

const PORT = 80;
const SOURCE = 'authorized';

const BLOCKS_FILE = './allowed_blocks.txt';
const BLOCKS_NAMESPACE = 'allowed_blocks_v1';

const RUN_OUTPUT_PATH = './runOutput.txt';

const TTL_DAYS = 7;
const DROP_RUNS_OLDER_THAN_DAYS = 30;

const BATCH_SIZE = 5000;
const ENABLE_STRICT_IP_VALIDATION = true;
const MAX_LINE_LENGTH = 512;

const ENABLE_BLOOM = true;
const SCAN_SIZE_EXPECTED_UNIQUES = 5_000_000;
const BLOOM_TARGET_FP = 0.0001;
const BLOOM_GROWTH_FACTOR = 2.0;
const BLOOM_MAX_BYTES = 128 * 1024 * 1024;

const SCAN_N_BLOCKS = parseInt(process.env.SCAN_N_BLOCKS || '5', 10);

// Producer command for THIS script (set this to whatever you run)
// Example:
// const PRODUCER_CMD = 'cat';
// const PRODUCER_ARGS_TEMPLATE = (ipBlock) => [ './ips.txt' ];
//
// You currently build args inline below; keep it that way if you prefer.
const PRODUCER_CMD = 'zmap'; // <-- set me

// Optional variables for a zmap-style producer (only used if you build args that way)
const ZMAP_RATE_PPS = '5000';
const ZMAP_COOLDOWN = '5';

//
// END CONFIGURATION
//

const { spawn } = require('child_process');
const readline = require('readline');
const net = require('net');
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');
const { iterateBlocks } = require('./iterateBlocks');

let sqlite3;
try {
    sqlite3 = require('sqlite3');
} catch {
    console.error('Missing dependency: sqlite3');
    process.exit(1);
}

/* -------------------- utils -------------------- */

function nowSec() { return Math.floor(Date.now() / 1000); }
function daysToSeconds(d) { return Math.floor(d * 86400); }
function sanitizeIdent(s) { return String(s).replace(/[^a-zA-Z0-9_]/g, '_'); }

function makeRunId() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const stamp =
        `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_` +
        `${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
    const rand = crypto.randomBytes(3).toString('hex');
    return `run_${stamp}_${rand}`;
}

/* -------------------- PLAIN TEXT LOGGER -------------------- */

function createTextLogger(filePath) {
    const abs = path.resolve(filePath);
    fs.mkdirSync(path.dirname(abs), { recursive: true });

    // Clear log at process start
    try { fs.writeFileSync(abs, ''); } catch { }

    const ws = fs.createWriteStream(abs, { flags: 'a' });

    function write(line) {
        const s = String(line ?? '');
        ws.write(s.endsWith('\n') ? s : s + '\n');
    }

    return {
        info(msg) { write(msg); },
        warn(msg) { write(`WARN: ${msg}`); },
        error(msg) { write(`ERROR: ${msg}`); },
        raw(_stream, chunk) {
            const text = Buffer.isBuffer(chunk) ? chunk.toString('utf8') : String(chunk ?? '');
            ws.write(text);
        },
        close() {
            try { ws.end(); } catch { }
        },
        path: abs,
    };
}

/* -------------------- sqlite helpers -------------------- */

function run(db, sql, params = []) {
    return new Promise((resolve, reject) => {
        db.run(sql, params, function (err) {
            if (err) reject(err);
            else resolve(this);
        });
    });
}

function all(db, sql, params = []) {
    return new Promise((resolve, reject) => {
        db.all(sql, params, function (err, rows) {
            if (err) reject(err);
            else resolve(rows);
        });
    });
}

function closeDb(db) {
    return new Promise((resolve) => {
        try { db.close(() => resolve()); } catch { resolve(); }
    });
}

/* -------------------- IP extraction -------------------- */

function extractIp(line) {
    const t = String(line || '').trim();
    if (!t) return null;

    const s = t.replace(/^\[|\]$/g, '');
    if (net.isIP(s)) return s;

    const m4 = s.match(/^(\d{1,3}(?:\.\d{1,3}){3}):\d+$/);
    if (m4 && net.isIP(m4[1])) return m4[1];

    const m6 = t.match(/^\[([^\]]+)\]:(\d+)$/);
    if (m6 && net.isIP(m6[1])) return m6[1];

    return null;
}

/* -------------------- main -------------------- */

(async function main() {
  const log = createTextLogger(RUN_OUTPUT_PATH);
  log.info(`Logging to ${log.path}`);

  if (!PRODUCER_CMD) {
    log.error('PRODUCER_CMD is empty. Set PRODUCER_CMD in config.');
    throw new Error('PRODUCER_CMD is empty. Set PRODUCER_CMD in config.');
  }

  fs.mkdirSync(path.dirname(path.resolve(DB_PATH)), { recursive: true });
  const db = new sqlite3.Database(DB_PATH);

  // Soft-failure policy: do NOT stop the whole loop on one block failure.
  // We'll only stop on "hard" setup failures (like iterateBlocks returning nothing).
  let hardAbort = false;

  for (let scanIndex = 1; scanIndex <= SCAN_N_BLOCKS; scanIndex++) {
    if (hardAbort) break;

    const runTable = sanitizeIdent(makeRunId());
    let metaInserted = false;
    let runTableCreated = false;

    try {
      await run(db, `
        CREATE TABLE IF NOT EXISTS runs_meta (
          run_table TEXT PRIMARY KEY,
          created_at INTEGER NOT NULL,
          port INTEGER NOT NULL,
          source TEXT NOT NULL
        );
      `);

      await run(db, `
        CREATE TABLE IF NOT EXISTS run_block (
          run_table TEXT PRIMARY KEY,
          ip_block TEXT NOT NULL,
          ip_block_start INTEGER NOT NULL,
          ip_block_end INTEGER NOT NULL,
          ip_block_file TEXT NOT NULL,
          ip_block_namespace TEXT NOT NULL,
          picked_at INTEGER NOT NULL
        );
      `);

      // Per-run table first
      await run(db, `
        CREATE TABLE IF NOT EXISTS "${runTable}" (
          ip TEXT PRIMARY KEY,
          port INTEGER NOT NULL,
          source TEXT NOT NULL,
          first_seen INTEGER NOT NULL,
          last_seen INTEGER NOT NULL,
          seen_count INTEGER NOT NULL
        );
      `);
      runTableCreated = true;

      await run(db, `CREATE INDEX IF NOT EXISTS "idx_${runTable}_last_seen" ON "${runTable}"(last_seen);`);

      await run(db,
        `INSERT INTO runs_meta(run_table, created_at, port, source) VALUES(?,?,?,?)`,
        [runTable, nowSec(), PORT, SOURCE]
      );
      metaInserted = true;

      // Pick a block
      const blockIter = await iterateBlocks(db, BLOCKS_FILE, {
        namespace: BLOCKS_NAMESPACE,
        runId: runTable,
        ignoreBlank: true,
      });

      const picked = await blockIter.nextMeta();
      if (!picked || !picked.text) {
        log.error('iterateBlocks returned empty block (hard abort)');
        hardAbort = true;
        throw new Error('iterateBlocks returned empty block');
      }

      const IP_BLOCK = picked.text.trim();
      log.info(`Scanning block ${scanIndex}/${SCAN_N_BLOCKS}: ${IP_BLOCK}`);

      await run(db, `
        INSERT INTO run_block
        (run_table, ip_block, ip_block_start, ip_block_end, ip_block_file, ip_block_namespace, picked_at)
        VALUES (?,?,?,?,?,?,?)
      `, [
        runTable,
        IP_BLOCK,
        picked.startByte,
        picked.endByte,
        path.resolve(BLOCKS_FILE),
        BLOCKS_NAMESPACE,
        nowSec(),
      ]);

      const PRODUCER_ARGS = [
        '-p', String(PORT),
        IP_BLOCK,
        '-r', ZMAP_RATE_PPS,
        '--cooldown-time', ZMAP_COOLDOWN,
        '-q',
        '-i', 'ens6',
        '--gateway-mac', '82:01:fa:1c:fa:1d'
      ];

      const child = spawn(PRODUCER_CMD, PRODUCER_ARGS, {
        stdio: ['ignore', 'pipe', 'pipe'],
      });

      child.stderr.on('data', (d) => log.raw('child_stderr', d));

      const rl = readline.createInterface({ input: child.stdout });

      // Always resolve; never throw from close handler
      const childCloseP = new Promise((resolve) => {
        child.on('close', (code, signal) => {
          try { rl.close(); } catch {}
          resolve({ code, signal });
        });
      });

      // Soft failure: record error but continue to next block
      let childErrored = false;
      child.on('error', (err) => {
        childErrored = true;
        log.error(`Producer error: ${err.message}`);
        try { rl.close(); } catch {}
      });

      const stmt = db.prepare(`
        INSERT INTO "${runTable}" (ip, port, source, first_seen, last_seen, seen_count)
        VALUES (?, ?, ?, ?, ?, 1)
        ON CONFLICT(ip) DO UPDATE SET
          last_seen=excluded.last_seen,
          seen_count="${runTable}".seen_count+1
      `);

      let total = 0;

      for await (const line of rl) {
        if (line.length > MAX_LINE_LENGTH) continue;
        const ip = extractIp(line);
        if (!ip) continue;
        if (ENABLE_STRICT_IP_VALIDATION && net.isIP(ip) === 0) continue;

        try {
          stmt.run(ip, PORT, SOURCE, nowSec(), nowSec());
          total++;
        } catch (e) {
          // Soft: ignore edge-case stmt errors and keep reading
        }
      }

      const { code, signal } = await childCloseP;

      try { stmt.finalize(); } catch {}

      // Soft failure: log but do NOT stop further blocks
      if (childErrored || code !== 0) {
        log.error(`Block failed (soft): runTable=${runTable} ip_block=${IP_BLOCK} code=${code} signal=${signal || ''}`);
      }

      log.info(`Run done (${total} rows)`);
    } catch (e) {
      // For soft failures, we still clean up stale meta so dashboard doesn't query missing tables,
      // but we do NOT stop the loop unless hardAbort was set.
      log.error(`Run failed; cleaning up: ${e && (e.stack || e.message) ? (e.stack || e.message) : String(e)}`);

      try {
        if (metaInserted) {
          await run(db, `DELETE FROM run_block WHERE run_table=?`, [runTable]).catch(() => {});
          await run(db, `DELETE FROM runs_meta WHERE run_table=?`, [runTable]).catch(() => {});
        }
      } catch {}

      try {
        if (runTableCreated) {
          await run(db, `DROP TABLE IF EXISTS "${runTable}"`).catch(() => {});
        }
      } catch {}

      // IMPORTANT: do NOT set hardAbort here; continue to next block
    }
  }

  await closeDb(db);
  log.info('All scans complete');
  log.close();
})().catch((e) => {
  try {
    fs.appendFileSync(
      path.resolve(RUN_OUTPUT_PATH),
      `FATAL: ${String(e && e.stack ? e.stack : e)}\n`
    );
  } catch {}
  console.error(e);
  process.exit(1);
});

---server.js---
// --- server.js ---
'use strict';

// Load .env if present (dashboard-controlled vars)
require('dotenv').config();

const path = require('path');
const express = require('express');

const dashboardRoutes = require('./src/routes/dashboard');
const scheduler = require('./src/lib/scheduler');

const app = express();

// View engine (Pug)
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');

// Middleware
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: false }));

// Static assets
app.use('/public', express.static(path.join(__dirname, 'public')));

// Routes
app.use('/', dashboardRoutes);

// Start scheduler background loop so the server runs scans based on dashboard delay
scheduler.startBackgroundLoop();

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
  // eslint-disable-next-line no-console
  console.log(`[dashboard] listening on http://localhost:${port}`);
});

---src/lib/db.js---
// --- src/lib/db.js ---
'use strict';

const sqlite3 = require('sqlite3');
const crypto = require('crypto');

function openDb(dbPath) {
  return new sqlite3.Database(dbPath);
}

function run(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.run(sql, params, function (err) {
      if (err) reject(err);
      else resolve(this);
    });
  });
}

function get(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.get(sql, params, function (err, row) {
      if (err) reject(err);
      else resolve(row);
    });
  });
}

function all(db, sql, params = []) {
  return new Promise((resolve, reject) => {
    db.all(sql, params, function (err, rows) {
      if (err) reject(err);
      else resolve(rows);
    });
  });
}

function closeDb(db) {
  return new Promise((resolve) => {
    try { db.close(() => resolve()); } catch { resolve(); }
  });
}

async function tableExists(db, tableName) {
  const name = String(tableName || '');
  if (!name) return false;
  const row = await get(db, `SELECT name FROM sqlite_master WHERE type='table' AND name=?`, [name]).catch(() => null);
  return !!(row && row.name);
}

function sha256(text) {
  return crypto.createHash('sha256').update(String(text)).digest('hex');
}

module.exports = {
  openDb,
  run,
  get,
  all,
  closeDb,
  tableExists,
  sha256
};

---src/lib/envfile.js---
'use strict';

const fs = require('fs');
const path = require('path');

const ENV_PATH = process.env.ENV_PATH || path.resolve('./.env');

function parseEnv(text) {
  const out = {};
  const lines = String(text || '').split(/\r?\n/);
  for (const line of lines) {
    if (!line || /^\s*#/.test(line)) continue;
    const idx = line.indexOf('=');
    if (idx === -1) continue;
    const k = line.slice(0, idx).trim();
    let v = line.slice(idx + 1);
    // keep raw value (no unescaping)
    out[k] = v;
  }
  return out;
}

function serializeEnv(map, originalText) {
  const origLines = String(originalText || '').split(/\r?\n/);
  const seen = new Set();
  const outLines = [];

  for (const line of origLines) {
    if (!line || /^\s*#/.test(line) || line.indexOf('=') === -1) {
      outLines.push(line);
      continue;
    }
    const idx = line.indexOf('=');
    const k = line.slice(0, idx).trim();
    if (Object.prototype.hasOwnProperty.call(map, k)) {
      outLines.push(`${k}=${map[k]}`);
      seen.add(k);
    } else {
      outLines.push(line);
    }
  }

  // append any new keys
  for (const [k, v] of Object.entries(map)) {
    if (!seen.has(k)) outLines.push(`${k}=${v}`);
  }

  // trim trailing blank lines but keep final newline
  while (outLines.length && outLines[outLines.length - 1] === '') outLines.pop();
  return outLines.join('\n') + '\n';
}

function readEnvFile() {
  try {
    const raw = fs.readFileSync(ENV_PATH, 'utf8');
    return { raw, map: parseEnv(raw) };
  } catch {
    return { raw: '', map: {} };
  }
}

function writeEnvKey(key, value) {
  const { raw, map } = readEnvFile();
  map[key] = String(value);
  const next = serializeEnv(map, raw);
  fs.writeFileSync(ENV_PATH, next, 'utf8');
  return { path: ENV_PATH, map };
}

function getEnvKey(key) {
  const { map } = readEnvFile();
  return map[key];
}

module.exports = { ENV_PATH, readEnvFile, writeEnvKey, getEnvKey };

---src/lib/log-tail.js---
'use strict';

const fs = require('fs');
const path = require('path');

const LOG_PATH = process.env.LOG_PATH || path.resolve('./scan.log');
const MAX_LOG_BYTES_PER_POLL = Number(process.env.MAX_LOG_BYTES_PER_POLL || (64 * 1024));

const logStateByRun = new Map();

function getLogState(runTable) {
  if (!logStateByRun.has(runTable)) {
    logStateByRun.set(runTable, {
      offset: 0,
      startedAtMs: Date.now(),
      stats: {
        total_lines: 0,
        accepted: 0,
        rejected: 0,
        bloom_skipped: 0,
        last_rate: null
      }
    });
  }
  return logStateByRun.get(runTable);
}

function resetLogState(runTable) {
  logStateByRun.set(runTable, {
    offset: 0,
    startedAtMs: Date.now(),
    stats: {
      total_lines: 0,
      accepted: 0,
      rejected: 0,
      bloom_skipped: 0,
      last_rate: null
    }
  });
}

// Heuristic regexes based on safe_scan.js output
const RX = {
  total: /lines\s*processed[:=]\s*(\d+)/i,
  accepted: /accepted[:=]\s*(\d+)/i,
  rejected: /rejected[:=]\s*(\d+)/i,
  bloom: /bloom(?:_skipped| skipped)?[:=]\s*(\d+)/i,
  rate: /rate[:=]\s*([\d.]+)\s*(?:ips\/s|lines\/s)?/i
};

function parseStats(text, st) {
  if (!text) return;
  st.stats.total_lines += (text.match(/\n/g) || []).length;

  let m;
  if ((m = RX.accepted.exec(text))) st.stats.accepted = Number(m[1]);
  if ((m = RX.rejected.exec(text))) st.stats.rejected = Number(m[1]);
  if ((m = RX.bloom.exec(text))) st.stats.bloom_skipped = Number(m[1]);
  if ((m = RX.rate.exec(text))) st.stats.last_rate = Number(m[1]);
}

function readNew(runTable) {
  const st = getLogState(runTable);

  let stat;
  try {
    stat = fs.statSync(LOG_PATH);
  } catch {
    return { text: '', offset: st.offset, missing: true, log_path: LOG_PATH, stats: st.stats };
  }

  if (stat.size < st.offset) st.offset = 0;

  const start = st.offset;
  const remaining = stat.size - start;
  if (remaining <= 0) return { text: '', offset: st.offset, missing: false, log_path: LOG_PATH, stats: st.stats };

  const toRead = Math.min(remaining, MAX_LOG_BYTES_PER_POLL);
  const fd = fs.openSync(LOG_PATH, 'r');
  try {
    const buf = Buffer.allocUnsafe(toRead);
    const n = fs.readSync(fd, buf, 0, toRead, start);
    st.offset = start + n;
    const text = buf.slice(0, n).toString('utf8');
    parseStats(text, st);
    return { text, offset: st.offset, missing: false, log_path: LOG_PATH, stats: st.stats };
  } finally {
    fs.closeSync(fd);
  }
}

module.exports = { LOG_PATH, resetLogState, readNew };

---src/lib/run-output.js---
// --- src/lib/run-output.js ---
'use strict';

const fs = require('fs');
const path = require('path');

// Plain-text run output (one console line == one file line)
const OUTPUT_TXT_PATH = process.env.RUN_OUTPUT_TXT_PATH || path.resolve('./runOutput.txt');

// Small JSON state for status/meta/stats (NOT a log)
const STATE_PATH = process.env.RUN_STATE_PATH || path.resolve('./runState.json');

const MAX_STATE_BYTES = Number(process.env.RUN_STATE_MAX_BYTES || 64 * 1024);

// per-client tail cursor for OUTPUT_TXT_PATH
const tailTxtByKey = new Map(); // key -> { byteOffset: number }

function ensureDir(p) {
  try { fs.mkdirSync(path.dirname(p), { recursive: true }); } catch {}
}

function defaultState() {
  return { running: false, meta: {}, stats: {}, updatedAtMs: 0 };
}

function readStateSafe() {
  try {
    const raw = fs.readFileSync(STATE_PATH, 'utf8');
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return defaultState();
    return {
      running: !!parsed.running,
      meta: (parsed.meta && typeof parsed.meta === 'object') ? parsed.meta : {},
      stats: (parsed.stats && typeof parsed.stats === 'object') ? parsed.stats : {},
      updatedAtMs: Number(parsed.updatedAtMs || 0) || 0
    };
  } catch {
    return defaultState();
  }
}

function writeStateSafe(state) {
  const safe = {
    running: !!state.running,
    meta: state.meta && typeof state.meta === 'object' ? state.meta : {},
    stats: state.stats && typeof state.stats === 'object' ? state.stats : {},
    updatedAtMs: Date.now()
  };
  try {
    ensureDir(STATE_PATH);
    const out = JSON.stringify(safe);
    if (Buffer.byteLength(out, 'utf8') <= MAX_STATE_BYTES) {
      fs.writeFileSync(STATE_PATH, out, 'utf8');
    }
  } catch {
    // ignore
  }
  return safe;
}

function peekState() {
  return readStateSafe();
}

/**
 * Tail OUTPUT_TXT_PATH as plain text.
 * - Uses per-key byte offsets
 * - `reset=1` jumps to EOF (UI clears and only shows fresh content)
 */
function tail(key, reset = false) {
  const k = String(key || 'global');
  const state = readStateSafe();

  ensureDir(OUTPUT_TXT_PATH);

  let st;
  try {
    st = fs.statSync(OUTPUT_TXT_PATH);
  } catch {
    // file missing => nothing to tail
    tailTxtByKey.set(k, { byteOffset: 0 });
    return {
      ok: true,
      running: !!state.running,
      stats: state.stats || {},
      meta: state.meta || {},
      text: '',
      source: 'runOutput.txt',
      output_path: OUTPUT_TXT_PATH,
      totalBytes: 0
    };
  }

  if (reset || !tailTxtByKey.has(k)) {
    tailTxtByKey.set(k, { byteOffset: st.size });
    return {
      ok: true,
      running: !!state.running,
      stats: state.stats || {},
      meta: state.meta || {},
      text: '',
      source: 'runOutput.txt',
      output_path: OUTPUT_TXT_PATH,
      totalBytes: st.size
    };
  }

  const cur = tailTxtByKey.get(k);
  const from = Math.max(0, Number(cur.byteOffset || 0));
  const to = st.size;

  // handle truncation/rotation
  const safeFrom = from > to ? 0 : from;

  let text = '';
  if (to > safeFrom) {
    const fd = fs.openSync(OUTPUT_TXT_PATH, 'r');
    try {
      const len = to - safeFrom;
      const buf = Buffer.allocUnsafe(len);
      fs.readSync(fd, buf, 0, len, safeFrom);
      text = buf.toString('utf8');
    } finally {
      fs.closeSync(fd);
    }
  }

  cur.byteOffset = to;

  return {
    ok: true,
    running: !!state.running,
    stats: state.stats || {},
    meta: state.meta || {},
    text,
    source: 'runOutput.txt',
    output_path: OUTPUT_TXT_PATH,
    totalBytes: to
  };
}

/* ------------------- writer helpers ------------------- */

function clearOutputFile() {
  try {
    ensureDir(OUTPUT_TXT_PATH);
    fs.writeFileSync(OUTPUT_TXT_PATH, '', 'utf8');
  } catch {
    // ignore
  }
  // reset all client cursors so they don't “seek past” the new empty file
  tailTxtByKey.clear();
}

function appendLine(line) {
  const s = String(line ?? '');
  try {
    ensureDir(OUTPUT_TXT_PATH);
    fs.appendFileSync(OUTPUT_TXT_PATH, s.endsWith('\n') ? s : (s + '\n'), 'utf8');
  } catch {
    // ignore
  }
}

function beginRun(meta = {}) {
  // requirement: new run clears run output
  clearOutputFile();

  writeStateSafe({
    running: true,
    meta: { ...meta, startedAtMs: Date.now() },
    stats: {}
  });

  appendLine(`[dashboard] starting scan: ${meta.cmd || ''}`.trim());
}

function setStats(stats = {}) {
  const st = readStateSafe();
  writeStateSafe({ running: !!st.running, meta: st.meta || {}, stats: stats || {} });
}

function endRun(result = {}) {
  const st = readStateSafe();
  appendLine(
    `[dashboard] scan ended: code=${result.code} signal=${result.signal}` +
    (result.error ? ` error=${result.error}` : '')
  );
  writeStateSafe({
    running: false,
    meta: { ...(st.meta || {}), endedAtMs: Date.now(), result },
    stats: st.stats || {}
  });
}

module.exports = {
  OUTPUT_TXT_PATH,
  STATE_PATH,
  peekState,
  tail,
  beginRun,
  appendLine,
  setStats,
  endRun
};

---src/lib/scan-model.js---
// --- scan-model.js ---
'use strict';

const { openDb, get, all, isSafeIdent } = require('./db');

/**
 * Defensive helpers so the dashboard never dies when:
 * - runs_meta exists but the per-run table was deleted / never created
 * - DB is fresh and tables don't exist yet
 */

async function tableExists(db, tableName) {
  try {
    const row = await get(db, `
      SELECT name
      FROM sqlite_master
      WHERE type='table' AND name = ?
      LIMIT 1
    `, [tableName]);
    return !!(row && row.name);
  } catch {
    return false;
  }
}

async function safeHasCoreTables(db) {
  // If the DB is new or schema not created yet, avoid throwing
  const hasRuns = await tableExists(db, 'runs_meta');
  const hasBlock = await tableExists(db, 'run_block');
  return { hasRuns, hasBlock };
}

/**
 * Returns the newest run that actually has a backing per-run table.
 * If no valid run exists, returns null.
 */
async function getLatestRunMeta() {
  const db = openDb();
  try {
    const { hasRuns } = await safeHasCoreTables(db);
    if (!hasRuns) return null;

    // Grab a small window of recent runs and pick the first whose table exists
    const rows = await all(db, `
      SELECT run_table, created_at, port, source,
             (SELECT MIN(created_at) FROM runs_meta) AS first_ever_created_at
      FROM runs_meta
      ORDER BY created_at DESC
      LIMIT 25
    `);

    for (const r of rows || []) {
      if (!r || !r.run_table) continue;
      if (!isSafeIdent(r.run_table)) continue;
      const ok = await tableExists(db, r.run_table);
      if (ok) return r;
    }

    return null;
  } catch (e) {
    // Never crash the dashboard due to schema or missing tables
    return null;
  } finally {
    try { db.close(); } catch {}
  }
}

async function getRunBlock(runTable) {
  if (!isSafeIdent(runTable)) return null;

  const db = openDb();
  try {
    const { hasBlock } = await safeHasCoreTables(db);
    if (!hasBlock) return null;

    const row = await get(db, `
      SELECT
        run_table,
        ip_block,
        ip_block_start,
        ip_block_end,
        ip_block_file,
        ip_block_namespace,
        picked_at
      FROM run_block
      WHERE run_table = ?
      LIMIT 1
    `, [runTable]);

    return row || null;
  } catch {
    return null;
  } finally {
    try { db.close(); } catch {}
  }
}

/**
 * Stats shape matches the current client usage in /public/js/dashboard.js:
 * - unique_ips
 * - total_observations
 * - ips_seen_last_60s
 * - first_seen_min
 * - last_seen_max
 */
async function getRunStats(runTable) {
  if (!isSafeIdent(runTable)) return null;

  const db = openDb();
  try {
    // If the per-run table doesn’t exist, return null (client will keep pills as-is)
    if (!(await tableExists(db, runTable))) return null;

    const stats = await get(db, `
      SELECT
        COUNT(*) AS unique_ips,
        COALESCE(SUM(seen_count), 0) AS total_observations,
        COALESCE(MIN(first_seen), 0) AS first_seen_min,
        COALESCE(MAX(last_seen), 0) AS last_seen_max
      FROM "${runTable}"
    `);

    const nowSec = Math.floor(Date.now() / 1000);

    const hot = await get(db, `
      SELECT COUNT(*) AS ips_seen_last_60s
      FROM "${runTable}"
      WHERE last_seen >= ?
    `, [nowSec - 60]);

    return {
      unique_ips: Number(stats?.unique_ips || 0) || 0,
      total_observations: Number(stats?.total_observations || 0) || 0,
      first_seen_min: Number(stats?.first_seen_min || 0) || 0,
      last_seen_max: Number(stats?.last_seen_max || 0) || 0,
      ips_seen_last_60s: Number(hot?.ips_seen_last_60s || 0) || 0
    };
  } catch (e) {
    // If meta points to a table that was never created (or got cleaned up), don't crash the dashboard.
    if (e && (e.code === 'SQLITE_ERROR' || e.code === 'SQLITE_MISUSE')) return null;
    throw e;
  } finally {
    try { db.close(); } catch {}
  }
}

/**
 * Latest rows for the run.
 * Returned row shape matches client table rendering:
 * ip, seen_count, last_seen, first_seen, source, port
 */
async function getLatestRows(runTable, limit = 200) {
  if (!isSafeIdent(runTable)) return [];

  const lim = Math.max(1, Math.min(500, Number(limit) || 200));
  const db = openDb();
  try {
    if (!(await tableExists(db, runTable))) return [];

    const rows = await all(db, `
      SELECT ip, seen_count, last_seen, first_seen, source, port
      FROM "${runTable}"
      ORDER BY last_seen DESC
      LIMIT ?
    `, [lim]);

    return Array.isArray(rows) ? rows : [];
  } catch (e) {
    if (e && (e.code === 'SQLITE_ERROR' || e.code === 'SQLITE_MISUSE')) return [];
    throw e;
  } finally {
    try { db.close(); } catch {}
  }
}

/**
 * Convenience bundle for your /api/latest-run route:
 * { meta, block, first_ever_created_at }
 */
async function getLatestRunBundle() {
  const meta = await getLatestRunMeta();
  if (!meta) {
    return { meta: null, block: null, first_ever_created_at: null };
  }
  const block = await getRunBlock(meta.run_table);
  const firstEver = Number(meta.first_ever_created_at || 0) || null;

  return {
    meta: {
      run_table: meta.run_table,
      created_at: Number(meta.created_at || 0) || 0,
      port: Number(meta.port || 0) || 0,
      source: meta.source || ''
    },
    block,
    first_ever_created_at: firstEver
  };
}

module.exports = {
  getLatestRunMeta,
  getRunBlock,
  getRunStats,
  getLatestRows,
  getLatestRunBundle
};

---src/lib/scheduler.js---
// --- src/lib/scheduler.js ---
'use strict';

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const runOutput = require('./run-output');
const { writeEnvKey } = require('./envfile');

const STATE_PATH = process.env.SCHED_STATE_PATH || path.resolve('./scheduleState.json');

const DEFAULT_SCAN_CMD = process.env.SCAN_CMD || 'node safe_scan.js';

const LOOP_MS = Number(process.env.SCHED_LOOP_MS || 500);

let loopTimer = null;
let runningChild = null;

function defaultState() {
  return {
    armed: false,
    delaySec: 0,
    nextRunAtMs: null,
    running: false,
    startedByDashboard: false,
    lastExit: null
  };
}

function readState() {
  try {
    const raw = fs.readFileSync(STATE_PATH, 'utf8');
    const j = JSON.parse(raw);
    return { ...defaultState(), ...(j || {}) };
  } catch {
    return defaultState();
  }
}

function writeState(next) {
  const s = { ...defaultState(), ...(next || {}) };
  try {
    fs.mkdirSync(path.dirname(STATE_PATH), { recursive: true });
    fs.writeFileSync(STATE_PATH, JSON.stringify(s), 'utf8');
  } catch {}
  return s;
}

function getState() {
  return readState();
}

function computeNextRun(delaySec) {
  const d = Math.max(1, Number(delaySec || 0));
  return Date.now() + (d * 1000);
}

function arm(delaySec, source = 'dashboard') {
  const d = Math.max(1, Number(delaySec || 0));
  // keep delay persisted so the UI countdown is stable
  writeEnvKey('SCAN_DELAY_SEC', String(d));

  const next = writeState({
    armed: true,
    delaySec: d,
    nextRunAtMs: computeNextRun(d),
    startedByDashboard: source === 'dashboard'
  });

  return { ok: true, state: next };
}

function cancel(source = 'dashboard') {
  const s = readState();
  const next = writeState({
    ...s,
    armed: false,
    nextRunAtMs: null,
    startedByDashboard: source === 'dashboard'
  });
  return { ok: true, state: next };
}

function runNow(source = 'dashboard') {
  const s = readState();
  const delay = Math.max(1, Number(s.delaySec || 60));
  const next = writeState({
    ...s,
    armed: true, // run-now implies “armed” for that cycle
    delaySec: delay,
    nextRunAtMs: Date.now() + 250, // very soon
    startedByDashboard: source === 'dashboard'
  });
  return { ok: true, state: next };
}

function startBackgroundLoop(scanCmd = DEFAULT_SCAN_CMD) {
  if (loopTimer) return;

  loopTimer = setInterval(async () => {
    const s = readState();

    if (!s.armed || s.running) return;
    if (!s.nextRunAtMs || Date.now() < s.nextRunAtMs) return;

    // fire
    writeState({ ...s, running: true, lastExit: null });

    // new run clears output + marks state
    runOutput.beginRun({ source: 'scheduler', cmd: scanCmd });

    // IMPORTANT: don't pipe stdout into dashboard (zmap uses stdout for results).
    // safe_scan.js should write to runOutput.txt itself.
    runningChild = spawn('bash', ['-lc', scanCmd], {
      stdio: ['ignore', 'ignore', 'pipe']
    });

    runningChild.stderr.on('data', (d) => {
      try { runOutput.appendLine(String(d).trimEnd()); } catch {}
    });

    runningChild.on('close', (code, signal) => {
      const s2 = readState();

      const exit = { code, signal };
      writeState({
        ...s2,
        running: false,
        lastExit: exit,
        nextRunAtMs: s2.armed ? computeNextRun(s2.delaySec || 60) : null
      });

      runOutput.endRun(exit);
      runningChild = null;
    });

    runningChild.on('error', (err) => {
      const s2 = readState();
      const exit = { code: 1, signal: null, error: err.message };
      writeState({ ...s2, running: false, lastExit: exit, armed: false, nextRunAtMs: null });
      runOutput.endRun(exit);
      runningChild = null;
    });
  }, LOOP_MS);
}

module.exports = {
  startBackgroundLoop,
  getState,
  arm,
  cancel,
  runNow
};

---src/routes/dashboard.js---
// --- src/routes/dashboard.js ---
// Express router for the dashboard UI + API.
//
// This router is wired to the rest of the project:
// - Scheduler state + run spawning is handled by src/lib/scheduler.js
// - Run console output + tailing is handled by src/lib/run-output.js
// - Run metadata + rows are read from the project's SQLite DB (default: ./online.sqlite)
//
// NOTE: DB access is best-effort and supports either `better-sqlite3` (sync) or `sqlite3` (async)
// if either dependency is installed.

'use strict';

const path = require('path');
const express = require('express');

const scheduler = require('../lib/scheduler');
const runOutput = require('../lib/run-output');

const router = express.Router();

// ---------------------------
// Paths (project-root relative)
// ---------------------------

// __dirname is: <project>/src/routes
const PROJECT_ROOT = path.resolve(__dirname, '..', '..');

const DEFAULT_DB_PATH = path.join(PROJECT_ROOT, 'online.sqlite');

// allow override via env; accept absolute or project-root relative
const DB_PATH = process.env.DB_PATH
  ? (path.isAbsolute(process.env.DB_PATH) ? process.env.DB_PATH : path.resolve(PROJECT_ROOT, process.env.DB_PATH))
  : DEFAULT_DB_PATH;

// For display only (tailing uses runOutput.OUTPUT_TXT_PATH)
const OUTPUT_PATH = runOutput.OUTPUT_TXT_PATH;

// ---------------------------
// Optional SQLite (best-effort)
// ---------------------------

let sqlite = null;
let db = null;

// Support either better-sqlite3 or sqlite3 if installed.
function tryInitDb() {
  if (db) return db;

  // better-sqlite3 (sync)
  try {
    // eslint-disable-next-line import/no-extraneous-dependencies
    const BetterSqlite3 = require('better-sqlite3');
    sqlite = { kind: 'better-sqlite3' };
    db = new BetterSqlite3(DB_PATH, { readonly: true });
    return db;
  } catch (_) {}

  // sqlite3 (async)
  try {
    // eslint-disable-next-line import/no-extraneous-dependencies
    const sqlite3 = require('sqlite3');
    sqlite = { kind: 'sqlite3', sqlite3 };
    db = new sqlite3.Database(DB_PATH, sqlite3.OPEN_READONLY);
    return db;
  } catch (_) {}

  return null;
}

function dbAll(sql, params = []) {
  const dbc = tryInitDb();
  if (!dbc) return Promise.reject(new Error('No sqlite driver found (install better-sqlite3 or sqlite3)'));

  if (sqlite.kind === 'better-sqlite3') {
    try {
      const stmt = dbc.prepare(sql);
      const rows = stmt.all(params);
      return Promise.resolve(rows);
    } catch (e) {
      return Promise.reject(e);
    }
  }

  return new Promise((resolve, reject) => {
    dbc.all(sql, params, (err, rows) => (err ? reject(err) : resolve(rows)));
  });
}

function dbGet(sql, params = []) {
  const dbc = tryInitDb();
  if (!dbc) return Promise.reject(new Error('No sqlite driver found (install better-sqlite3 or sqlite3)'));

  if (sqlite.kind === 'better-sqlite3') {
    try {
      const stmt = dbc.prepare(sql);
      const row = stmt.get(params);
      return Promise.resolve(row);
    } catch (e) {
      return Promise.reject(e);
    }
  }

  return new Promise((resolve, reject) => {
    dbc.get(sql, params, (err, row) => (err ? reject(err) : resolve(row)));
  });
}

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function safeTableName(input) {
  const s = String(input || '');
  // allow run_YYYYMMDD_HHMMSS_xxxxxx
  const cleaned = s.replace(/[^a-zA-Z0-9_]/g, '');
  return cleaned;
}

// ---------------------------
// Page route (pug render)
// ---------------------------

router.get(['/', '/dashboard'], (req, res) => {
  res.render('dashboard', {
    cfg: {
      dbPath: DB_PATH,
      outputPath: OUTPUT_PATH
    }
  });
});

// ---------------------------
// Tail endpoint (live console)
// ---------------------------
//
// Client expects: { text, source, running, ... }

router.get('/api/tail', (req, res) => {
  const key = String(req.query.key || 'global');
  const reset = String(req.query.reset || '0') === '1';

  try {
    const out = runOutput.tail(key, reset);
    return res.json(out);
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// ---------------------------
// Run + DB endpoints
// ---------------------------

// Expected by client: /api/run/latest -> { meta, block, firstEverCreatedAt }
router.get('/api/run/latest', async (req, res) => {
  try {
    const meta = await dbGet(
      `SELECT run_table, created_at, source, port
       FROM runs_meta
       ORDER BY created_at DESC
       LIMIT 1`
    ).catch(() => null);

    const firstEver = await dbGet(
      `SELECT MIN(created_at) AS first_ever_created_at FROM runs_meta`
    ).catch(() => null);

    let block = null;
    if (meta && meta.run_table) {
      block = await dbGet(
        `SELECT ip_block, picked_at, ip_block_namespace, ip_block_file
         FROM run_block
         WHERE run_table = ?
         ORDER BY picked_at DESC
         LIMIT 1`,
        [meta.run_table]
      ).catch(() => null);
    } else {
      // fallback: latest block overall
      block = await dbGet(
        `SELECT ip_block, picked_at, ip_block_namespace, ip_block_file, run_table
         FROM run_block
         ORDER BY picked_at DESC
         LIMIT 1`
      ).catch(() => null);
    }

    return res.json({
      meta: meta || null,
      block: block || null,
      firstEverCreatedAt: firstEver ? firstEver.first_ever_created_at : null
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// Expected by client: /api/run/:run/stats -> stats object
router.get('/api/run/:run/stats', async (req, res) => {
  const run = safeTableName(req.params.run);
  if (!run) return res.status(400).json({ ok: false, error: 'missing run' });

  try {
    const base = await dbGet(
      `SELECT
         COUNT(DISTINCT ip) AS unique_ips,
         COUNT(1) AS total_observations,
         MIN(first_seen) AS first_seen,
         MAX(last_seen) AS last_seen
       FROM "${run}"`
    );

    const nowSec = Math.floor(Date.now() / 1000);
    const hot = await dbGet(
      `SELECT COUNT(DISTINCT ip) AS hot_unique_ips
       FROM "${run}"
       WHERE last_seen >= ?`,
      [nowSec - 60]
    ).catch(() => ({ hot_unique_ips: 0 }));

    return res.json({
      unique_ips: base?.unique_ips ?? 0,
      total_observations: base?.total_observations ?? 0,
      hot_unique_ips: hot?.hot_unique_ips ?? 0,
      first_seen: base?.first_seen ?? null,
      last_seen: base?.last_seen ?? null
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// Expected by client: /api/run/:run/rows?limit=50 -> array of rows
router.get('/api/run/:run/rows', async (req, res) => {
  const run = safeTableName(req.params.run);
  const limit = clamp(Number(req.query.limit || 50), 1, 500);

  if (!run) return res.status(400).json({ ok: false, error: 'missing run' });

  try {
    const rows = await dbAll(
      `SELECT
         ip,
         port,
         source,
         first_seen,
         last_seen,
         seen_count,
         "${run}" AS _run
       FROM "${run}"
       ORDER BY last_seen DESC
       LIMIT ?`,
      [limit]
    ).catch(() => []);

    return res.json(Array.isArray(rows) ? rows : []);
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// ---------------------------
// Scheduler endpoints (persisted state)
// ---------------------------

// Client expects: /api/schedule/status -> { armed, delaySec, nextRunAtMs, running, ... }
router.get('/api/schedule/status', (req, res) => {
  res.json(scheduler.getState());
});

// POST { delaySec }
router.post('/api/schedule/arm', express.json(), (req, res) => {
  const delaySec = Number(req.body && req.body.delaySec);

  if (!Number.isFinite(delaySec) || delaySec < 1) {
    return res.status(400).json({ ok: false, error: 'delaySec must be >= 1' });
  }

  const out = scheduler.arm(delaySec, 'dashboard');
  return res.json(out.state);
});

// POST (no body)
router.post('/api/schedule/disarm', (req, res) => {
  const out = scheduler.cancel('dashboard');
  return res.json(out.state);
});

// Alias for older UIs that send “cancel”
router.post('/api/schedule/cancel', (req, res) => {
  const out = scheduler.cancel('dashboard');
  return res.json(out.state);
});

// POST (no body)
router.post('/api/schedule/run-now', (req, res) => {
  const out = scheduler.runNow('dashboard');
  return res.json(out.state);
});

module.exports = router;

---validate_ip.js---
'use strict';

const fs = require('fs');
const dns = require('dns').promises;
const tls = require('tls');

/* -------------------- utils -------------------- */

function withTimeout(promise, ms, label = 'timeout') {
  let t;
  const timeout = new Promise((_, rej) => {
    t = setTimeout(() => rej(new Error(label)), ms);
  });
  return Promise.race([promise.finally(() => clearTimeout(t)), timeout]);
}

function daysBetween(a, b) {
  const ms = Math.abs(a.getTime() - b.getTime());
  return ms / (1000 * 60 * 60 * 24);
}

function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}

/* -------------------- IP helpers -------------------- */

function parseIPv4ToU32(ip) {
  const parts = ip.split('.');
  if (parts.length !== 4) return null;
  let n = 0;
  for (const p of parts) {
    const v = Number(p);
    if (!Number.isInteger(v) || v < 0 || v > 255) return null;
    n = (n << 8) | v;
  }
  return n >>> 0;
}

/* -------------------- rDNS -------------------- */

function looksDefaultRdns(host) {
  const h = host.toLowerCase();
  const patterns = [
    /\b\d{1,3}[-.]\d{1,3}[-.]\d{1,3}[-.]\d{1,3}\b/,
    /(static|dyn|dynamic|host|vps|vm|server|srv|node)\b/,
    /\b(ip|cust|customer)\b/,
    /(compute|cloud|vultr|linode|digitalocean|ovh|hetzner|aws|amazon|googleusercontent|azure|leaseweb|contabo|scaleway)\b/,
    /\bip[-.]\d{1,3}[-.]\d{1,3}[-.]\d{1,3}[-.]\d{1,3}\b/,
  ];
  return patterns.some((re) => re.test(h));
}

async function reverseDns(ip, timeoutMs = 1200) {
  try {
    const names = await withTimeout(dns.reverse(ip), timeoutMs);
    return Array.isArray(names) ? names : [];
  } catch {
    return [];
  }
}

/* -------------------- TLS (bonus-only) -------------------- */

async function fetchTlsCertMeta(ip, timeoutMs = 1800, servername) {
  return withTimeout(
    new Promise((resolve) => {
      const socket = tls.connect(
        {
          host: ip,
          port: 443,
          servername: servername || undefined,
          rejectUnauthorized: false,
        },
        () => {
          const cert = socket.getPeerCertificate(true);
          socket.end();
          if (!cert || !cert.valid_from) return resolve(null);
          resolve({
            valid_from: new Date(cert.valid_from),
          });
        }
      );

      socket.on('error', () => resolve(null));
      socket.setTimeout(timeoutMs, () => {
        socket.destroy();
        resolve(null);
      });
    }),
    timeoutMs + 200
  );
}

/* -------------------- scoring -------------------- */

const DEFAULT_WEIGHTS = Object.freeze({
  datacenter_asn: 90,
  defaultish_rdns: 5,
  tls_age_le_7d: 5,
  tls_age_le_30d: 3,
  tls_age_le_90d: 1,
});

/* -------------------- precomputed index -------------------- */

let _idx = null;

function u32View(buf, offsetBytes, lengthU32) {
  return new Uint32Array(buf.buffer, buf.byteOffset + offsetBytes, lengthU32);
}

function loadPrecomputed(indexBinPath, asnMapJsonPath) {
  const buf = fs.readFileSync(indexBinPath);
  if (buf.slice(0, 4).toString('utf8') !== 'ASNV') {
    throw new Error('Invalid ASN index (bad magic)');
  }

  const version = buf.readUInt32LE(4);
  if (version !== 1) {
    throw new Error(`Unsupported ASN index version ${version}`);
  }

  const count = buf.readUInt32LE(8);
  let off = 16;

  const starts = u32View(buf, off, count); off += count * 4;
  const ends   = u32View(buf, off, count); off += count * 4;
  const asns   = u32View(buf, off, count); off += count * 4;
  const prefix16 = u32View(buf, off, 65536 * 2);

  const map = JSON.parse(fs.readFileSync(asnMapJsonPath, 'utf8'));
  const asnList = Uint32Array.from(map.asn);
  const isDcList = Uint8Array.from(map.isDc);

  _idx = { starts, ends, asns, prefix16, asnList, isDcList };
}

/* -------------------- ASN lookup -------------------- */

function binarySearchAsn(asnList, asn) {
  let lo = 0, hi = asnList.length - 1;
  while (lo <= hi) {
    const mid = (lo + hi) >> 1;
    const v = asnList[mid];
    if (v === asn) return mid;
    if (v < asn) lo = mid + 1;
    else hi = mid - 1;
  }
  return -1;
}

function binarySearchRange(starts, ends, asns, ipU32, lo, hiExclusive) {
  let l = lo;
  let r = hiExclusive - 1;
  let idx = -1;

  while (l <= r) {
    const mid = (l + r) >> 1;
    if (starts[mid] <= ipU32) {
      idx = mid;
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }

  if (idx === -1) return null;
  return ipU32 <= ends[idx] ? asns[idx] : null;
}

function lookupAsnAndDatacenter(ip) {
  if (!_idx) return null;

  const ipU32 = parseIPv4ToU32(ip);
  if (ipU32 === null) return null;

  const prefix = (ipU32 >>> 16) & 0xffff;
  const lo = _idx.prefix16[prefix * 2];
  const hi = _idx.prefix16[prefix * 2 + 1];

  const asn = binarySearchRange(_idx.starts, _idx.ends, _idx.asns, ipU32, lo, hi);
  if (!asn) return { asn: null, isDatacenter: false };

  const pos = binarySearchAsn(_idx.asnList, asn);
  const isDatacenter = pos >= 0 ? _idx.isDcList[pos] === 1 : false;

  return { asn, isDatacenter };
}

/* -------------------- main API -------------------- */

async function evaluateIp(ip, opts = {}) {
  const {
    indexBinPath,
    asnMapJsonPath,
    tlsServername,
    enableRdns = true,
    enableTlsAge = true,
    weights = {},
  } = opts;

  if (!_idx) {
    if (!indexBinPath || !asnMapJsonPath) {
      throw new Error('Missing indexBinPath / asnMapJsonPath');
    }
    loadPrecomputed(indexBinPath, asnMapJsonPath);
  }

  const W = { ...DEFAULT_WEIGHTS, ...weights };
  const reasons = [];
  const signals = {};

  /* ASN (primary) */
  const asnInfo = lookupAsnAndDatacenter(ip);
  signals.asn = asnInfo;

  const isDatacenter = Boolean(asnInfo && asnInfo.isDatacenter);
  if (isDatacenter) reasons.push('datacenter_asn');

  /* rDNS (supporting) */
  if (enableRdns) {
    const rdns = await reverseDns(ip);
    signals.rdns = rdns;
    if (rdns.length && rdns.some(looksDefaultRdns)) {
      reasons.push('defaultish_rdns');
    }
  }

  /* TLS age (bonus-only) */
  let ageHint = null;
  if (enableTlsAge) {
    const cert = await fetchTlsCertMeta(ip, 1800, tlsServername);
    signals.tlsCert = cert;

    if (cert && cert.valid_from instanceof Date) {
      const ageDays = daysBetween(new Date(), cert.valid_from);
      signals.tlsCertAgeDays = ageDays;

      if (ageDays <= 7) { reasons.push('tls_age_le_7d'); ageHint = 'very_fresh_tls'; }
      else if (ageDays <= 30) { reasons.push('tls_age_le_30d'); ageHint = 'fresh_tls'; }
      else if (ageDays <= 90) { reasons.push('tls_age_le_90d'); ageHint = 'moderately_fresh_tls'; }
      else { ageHint = 'older_tls'; }
    }
  }

  const uniqReasons = [...new Set(reasons)];
  let score = 0;
  for (const r of uniqReasons) if (typeof W[r] === 'number') score += W[r];
  score = clamp(score, 0, 100);

  let label = 'datacenter_unlikely';
  if (score >= 70) label = 'datacenter_likely';
  else if (score >= 40) label = 'datacenter_possible';

  return {
    isDatacenter,   // ✅ NEW boolean (fast path)
    score,
    label,
    ageHint,
    reasons: uniqReasons,
    signals,
  };
}

module.exports = {
  loadPrecomputed,
  evaluateIp,

  // exposed for testing / metrics
  lookupAsnAndDatacenter,
  DEFAULT_WEIGHTS,
};

---version-control/ALLOWED.txt---
# scripts/ALLOWED.txt
public/
src/
version-control/
views/
.env
safe_scan.js
server.js
iterateBlocks.js
validate_ip.js
---version-control/dump-apply.js---
// scripts/dump-apply.js
const fs = require("fs");
const path = require("path");
const { validateDumpText } = require("./dump-validator");

const ROOT = process.cwd();
const STATE_PATH = path.join(ROOT, ".repo_state.json");
const VERSIONS_DIR = path.join(ROOT, "versions");
const README_DIR = path.join(VERSIONS_DIR, "readme");

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function loadState() {
  try {
    return JSON.parse(fs.readFileSync(STATE_PATH, "utf8"));
  } catch {
    return { active: null, history: [] };
  }
}

function saveState(state) {
  fs.writeFileSync(STATE_PATH, JSON.stringify(state, null, 2) + "\n");
}

function extractReadmeRaw(text) {
  const start = text.indexOf("---README---\n");
  if (start === -1) return null;
  const end = text.indexOf("---__META__---", start);
  return text
    .slice(start + 13, end === -1 ? undefined : end)
    .trimEnd();
}

function applyDumpFile(dumpPath) {
  ensureDir(VERSIONS_DIR);
  ensureDir(README_DIR);

  const dumpText = fs.readFileSync(dumpPath, "utf8");
  const parsed = validateDumpText(dumpText);

  for (const w of parsed.warnings) {
    console.warn(`[dump:apply] WARN: ${w}`);
  }

  for (const [rel, content] of parsed.files.entries()) {
    const outPath = path.join(ROOT, rel);
    fs.mkdirSync(path.dirname(outPath), { recursive: true });
    fs.writeFileSync(outPath, content, "utf8");
  }

  const readme =
    parsed.readmeText || extractReadmeRaw(dumpText);

  if (readme) {
    const out = path.join(
      README_DIR,
      `README_${parsed.meta.version}.md`
    );
    fs.writeFileSync(out, readme + "\n");
  }

  const state = loadState();
  const entry = {
    version: parsed.meta.version,
    appliedAt: new Date().toISOString(),
    fileCount: parsed.files.size,
  };

  state.active = entry;
  state.history.push(entry);
  saveState(state);

  return entry;
}

if (require.main === module) {
  const dumpPath = process.argv[2] || "dump.txt";
  const res = applyDumpFile(dumpPath);
  console.log(`Applied ${res.version}`);
}

module.exports = { applyDumpFile };

---version-control/dump-prompt.txt---
“Apply these changes to the current canonical repo state. This is a multi-file change requiring a full dump. Output ONLY a downloadable dump.txt (no inline full files). Dump must be lexicographically ordered ---filename--- sections, exclude middleware/fingerer.js, and include a final ---__META__--- JSON footer with version, sha256 of content above footer, and manifest matching the dump entries exactly.”
---version-control/dump-undo.js---
// scripts/dump-undo.js
const fs = require("fs");
const path = require("path");
const { validateDumpText } = require("./dump-validator");
const { applyDumpFile } = require("./dump-apply");

const ROOT = process.cwd();
const STATE_PATH = path.join(ROOT, ".repo_state.json");

const VERSIONS_DIR = path.join(ROOT, "versions");

function loadState() {
  try {
    return JSON.parse(fs.readFileSync(STATE_PATH, "utf8"));
  } catch {
    return { active: null, history: [] };
  }
}

function dumpPathForVersion(version) {
  return path.join(VERSIONS_DIR, `dump_${version}.txt`);
}

function warn(msg) {
  console.warn(`[dump:undo] ${msg}`);
}

function info(msg) {
  console.log(`[dump:undo] ${msg}`);
}

/**
 * Roll back the codebase to the rollback target declared by the current ACTIVE version's README.
 * If the rollback target can't be determined or the target dump file can't be found, do nothing and warn.
 */
function undoToActiveRollbackTarget() {
  const state = loadState();

  if (!state.active || !state.active.version) {
    warn("No active version found in .repo_state.json. Nothing to undo.");
    return { didUndo: false, reason: "no-active" };
  }

  const activeVersion = String(state.active.version);
  const activeDumpPath = dumpPathForVersion(activeVersion);

  if (!fs.existsSync(activeDumpPath)) {
    warn(`Active dump file not found: ${path.relative(ROOT, activeDumpPath)}. Nothing to undo.`);
    return { didUndo: false, reason: "active-dump-missing" };
  }

  // Read active dump and extract README rollback target (legacy-friendly)
  let parsed;
  try {
    const dumpText = fs.readFileSync(activeDumpPath, "utf8");
    parsed = validateDumpText(dumpText);
  } catch (e) {
    warn(`Failed to parse active dump (${path.relative(ROOT, activeDumpPath)}): ${e.message}`);
    warn("Nothing to undo.");
    return { didUndo: false, reason: "active-dump-invalid" };
  }

  if (!parsed.readmeValidation || !parsed.readmeValidation.fields) {
    warn(`Active version ${activeVersion} has no README/rollback info (legacy dump). Nothing to undo.`);
    return { didUndo: false, reason: "no-readme" };
  }

  const rollbackTarget = String(parsed.readmeValidation.fields.rollbackTarget || "").trim();
  if (!rollbackTarget) {
    warn(`Active version ${activeVersion} README is missing Rollback target. Nothing to undo.`);
    return { didUndo: false, reason: "no-rollback-target" };
  }

  const targetDumpPath = dumpPathForVersion(rollbackTarget);

  if (!fs.existsSync(targetDumpPath)) {
    warn(
      `Rollback target dump not found: ${path.relative(ROOT, targetDumpPath)}. ` +
        `No changes applied.`
    );
    return { didUndo: false, reason: "target-dump-missing", rollbackTarget };
  }

  info(`Active version: ${activeVersion}`);
  info(`Rollback target: ${rollbackTarget}`);
  info(`Applying: ${path.relative(ROOT, targetDumpPath)}`);

  // Apply the target dump (this updates .repo_state.json and extracts README sidecar per your rules)
  const result = applyDumpFile(targetDumpPath, { allowDelete: false });

  info(`Rollback complete. Active is now ${result.version} (sha256=${result.sha256})`);
  return { didUndo: true, from: activeVersion, to: result.version };
}

// CLI:
// node scripts/dump-undo.js
// npm run dump:undo
if (require.main === module) {
  try {
    const res = undoToActiveRollbackTarget();
    if (!res.didUndo) process.exitCode = 0;
  } catch (e) {
    warn(e.message || String(e));
    process.exitCode = 1;
  }
}

module.exports = { undoToActiveRollbackTarget };

---version-control/dump-validator.js---
// scripts/dump-validator.js
const path = require("path");
const fs = require("fs");

const ROOT = process.cwd();
const ALLOWED_PATH = path.join(__dirname, "ALLOWED.txt");

const FORBIDDEN = new Set(["middleware/fingerer.js"]);

function isBoundaryLine(line) {
  return /^---[^-\n].*---$/.test(line.trim());
}

function boundaryName(line) {
  return line.trim().slice(3, -3);
}

function normalizeRel(p) {
  return String(p).replace(/\\/g, "/").replace(/^\/+/, "").trim();
}

function compareLex(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

/* ================= ALLOW POLICY ================= */

function loadAllowPolicy() {
  if (!fs.existsSync(ALLOWED_PATH)) {
    return { enabled: false };
  }

  const lines = fs
    .readFileSync(ALLOWED_PATH, "utf8")
    .split("\n")
    .map((l) => l.trim())
    .filter(Boolean)
    .filter((l) => !l.startsWith("#"));

  const exact = new Set();
  const dirs = [];

  for (const l of lines) {
    if (l.endsWith("/")) {
      dirs.push(l);
    } else {
      exact.add(l);
    }
  }

  return { enabled: true, exact, dirs };
}

function isAllowed(rel, policy) {
  if (FORBIDDEN.has(rel)) return false;
  if (!policy.enabled) return true;
  if (policy.exact.has(rel)) return true;
  return policy.dirs.some((d) => rel.startsWith(d));
}

/* ================= DUMP VALIDATION ================= */

function validateDumpText(dumpText) {
  const warnings = [];

  if (typeof dumpText !== "string" || !dumpText.length) {
    throw new Error("dump is empty or invalid");
  }

  const metaBoundary = "---__META__---\n";
  const idx = dumpText.lastIndexOf(metaBoundary);
  if (idx === -1) throw new Error("Missing __META__ footer");

  const headerText = dumpText.slice(0, idx);
  const metaText = dumpText.slice(idx + metaBoundary.length);

  let meta;
  try {
    meta = JSON.parse(metaText.trim());
  } catch {
    throw new Error("Invalid __META__ JSON");
  }

  if (!meta.version || typeof meta.version !== "string") {
    throw new Error("__META__.version is required");
  }

  if ("sha256" in meta) {
    warnings.push("__META__.sha256 ignored (hashing removed)");
  }

  const lines = headerText.split("\n");
  const files = new Map();

  let current = null;
  let buf = [];
  let inReadme = false;
  let readmeBuf = [];

  function flush() {
    if (current) files.set(current, buf.join("\n"));
    current = null;
    buf = [];
  }

  for (const line of lines) {
    if (isBoundaryLine(line)) {
      const name = normalizeRel(boundaryName(line));

      if (name === "README") {
        flush();
        inReadme = true;
        continue;
      }

      if (inReadme) throw new Error("File found after README");

      if (files.has(name)) throw new Error(`Duplicate file: ${name}`);
      if (FORBIDDEN.has(name)) throw new Error(`Forbidden file: ${name}`);

      flush();
      current = name;
      continue;
    }

    if (inReadme) {
      readmeBuf.push(line);
    } else if (current) {
      buf.push(line);
    } else if (line.trim() !== "") {
      throw new Error("Content before first file boundary");
    }
  }

  flush();

  if (!files.size) throw new Error("No files in dump");

  if (Array.isArray(meta.manifest)) {
    const actual = [...files.keys()];
    if (meta.manifest.length !== actual.length) {
      warnings.push("manifest length mismatch (warn-only)");
    }
  } else {
    warnings.push("__META__.manifest missing/invalid (warn-only)");
  }

  const policy = loadAllowPolicy();
  if (policy.enabled) {
    for (const rel of files.keys()) {
      if (!isAllowed(rel, policy)) {
        throw new Error(`File not allowed by ALLOWED.txt: ${rel}`);
      }
    }
  }

  const readmeText = readmeBuf.length ? readmeBuf.join("\n").trimEnd() : null;

  return {
    files,
    meta,
    readmeText,
    warnings,
  };
}

module.exports = { validateDumpText };

---version-control/generate-dump.js---
// scripts/generate-dump.js
const fs = require("fs");
const path = require("path");

const ROOT = process.cwd();
const STATE_PATH = path.join(ROOT, ".repo_state.json");
const VERSIONS_DIR = path.join(ROOT, "versions");

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function loadState() {
  try {
    return JSON.parse(fs.readFileSync(STATE_PATH, "utf8"));
  } catch {
    return { active: null };
  }
}

function loadAllowed() {
  const p = path.join(__dirname, "ALLOWED.txt");
  if (!fs.existsSync(p)) throw new Error("Missing scripts/ALLOWED.txt");

  return fs
    .readFileSync(p, "utf8")
    .split("\n")
    .map((l) => l.trim())
    .filter(Boolean)
    .filter((l) => !l.startsWith("#"));
}

function collectFiles(list) {
  const out = [];

  for (const entry of list) {
    const abs = path.join(ROOT, entry);
    if (!fs.existsSync(abs)) continue;

    const st = fs.statSync(abs);
    if (st.isFile()) out.push(entry);
    else if (st.isDirectory()) walk(abs, entry, out);
  }

  return out.sort();
}

function walk(abs, rel, out) {
  for (const name of fs.readdirSync(abs)) {
    const a = path.join(abs, name);
    const r = path.posix.join(rel, name);
    const st = fs.statSync(a);
    if (st.isDirectory()) walk(a, r, out);
    else if (st.isFile()) out.push(r);
  }
}

function generateDump() {
  ensureDir(VERSIONS_DIR);

  const state = loadState();
  const version =
    process.env.npm_config_version ||
    state.active?.version ||
    "v0.0.0";

  const allowed = loadAllowed();
  const files = collectFiles(allowed);

  let body = "";
  const manifest = [];

  for (const rel of files) {
    const content = fs.readFileSync(path.join(ROOT, rel), "utf8");
    body += `---${rel}---\n${content}\n`;
    manifest.push(rel);
  }

  const dump =
    body +
    `---README---\n# Dump README\n\nGenerated snapshot.\n\n` +
    `---__META__---\n` +
    JSON.stringify(
      {
        version,
        manifest,
      },
      null,
      2
    ) +
    "\n";

  const outPath = path.join(VERSIONS_DIR, `dump_${version}.txt`);
  fs.writeFileSync(outPath, dump, "utf8");

  console.log(`Generated ${path.relative(ROOT, outPath)}`);
}

if (require.main === module) {
  generateDump();
}

module.exports = { generateDump };

---version-control/print-active.js---
// scripts/print-active.js
const fs = require("fs");
const path = require("path");

const STATE_PATH = path.join(process.cwd(), ".repo_state.json");

function printActive() {
  if (!fs.existsSync(STATE_PATH)) {
    console.log("No repo state found. No dump has been applied yet.");
    process.exit(0);
  }

  let state;
  try {
    state = JSON.parse(fs.readFileSync(STATE_PATH, "utf8"));
  } catch {
    console.error("Failed to read .repo_state.json (corrupt JSON)");
    process.exit(1);
  }

  if (!state.active) {
    console.log("Repo state exists, but no active dump is set.");
    process.exit(0);
  }

  const a = state.active;

  console.log("Active repo dump");
  console.log("----------------");
  console.log(`Version    : ${a.version}`);
  console.log(`SHA256     : ${a.sha256}`);
  console.log(`Applied at : ${a.appliedAt}`);
  console.log(`Files      : ${a.fileCount}`);

  if (Array.isArray(state.history)) {
    console.log(`History    : ${state.history.length} total applied dumps`);
  }
}

if (require.main === module) {
  printActive();
}

module.exports = { printActive };

---views/dashboard.pug---
extends layout
block content
  .wrap
    header.header
      .title
        span.dot
        .tcopy
          .tmain SCAN DASH // LIVE VIEW
          .subtitle
            span#hdrLastBlock Last block: —
            br
            span#hdrLastTime Last scan: —
            br
            span#hdrFirstEver First scrape: —

      .pills
        .pill
          span.label UNIQUE
          span.value#pUnique 0
        .pill
          span.label OBS
          span.value#pObs 0
        .pill
          span.label HOT
          span.value#pHot 0

    .grid
      .panel.terminal
        .panelHeader
          span.panelTitle TERMINAL
          span.panelRight#termMeta —
        pre.console#console

      .panel.sched
        .schedHead
          .hleft
            | NEXT SCAN
            span.mono#countdown(style="margin-left:10px") —
          .tag#schedState —
        .schedBody
          .row
            label(for="delayMin") delay_minutes
            input#delayMin(type="number" min="1" step="1" value="15")
          .row
            button#armBtn Arm
            button#cancelBtn.secondary Cancel
            button#runNowBtn.ghost Run now

      .panel.results
        .panelHeader
          span.panelTitle RESULTS
          span.panelRight#runMeta —
        .tableWrap
          table.table
            thead
              tr
                th IP
                th LAST SEEN
                th SEEN
            tbody#rowsBody
              tr
                td(colspan="3").muted waiting…

---views/error.pug---
extends layout

block content
  main(style="padding:18px")
    h1(style="font-family: var(--mono); margin: 0 0 10px") #{title}
    p(style="font-family: var(--mono); color: var(--muted)") #{message}
    if status
      p(style="font-family: var(--mono); color: var(--muted)") status=#{status}

---views/layout.pug---
doctype html
html(lang="en")
  head
    meta(charset="utf-8")
    meta(name="viewport", content="width=device-width, initial-scale=1")
    title #{title}
    link(rel="stylesheet", href="/public/css/terminal.css")
  body(class="scanlines")
    //- scanlines MUST be its own layer (so it doesn't collide with body:before grid)
    div.scanlinesOverlay(aria-hidden="true")
    //- three laser grid layers (A/B via body pseudos, C via this div)
    div.laser3(aria-hidden="true")
    //- rare “connection loss fuzz” overlay (toggled by JS)
    div.fuzzOverlay(aria-hidden="true")
    block content
    script(src="/public/js/dashboard.js" defer)

---README---
# Dump README

Generated snapshot.

---__META__---
{
  "version": "v0.0.0",
  "manifest": [
    ".env",
    "iterateBlocks.js",
    "public/css/terminal.css",
    "public/js/dashboard.js",
    "safe_scan.js",
    "server.js",
    "src/lib/db.js",
    "src/lib/envfile.js",
    "src/lib/log-tail.js",
    "src/lib/run-output.js",
    "src/lib/scan-model.js",
    "src/lib/scheduler.js",
    "src/routes/dashboard.js",
    "validate_ip.js",
    "version-control/ALLOWED.txt",
    "version-control/dump-apply.js",
    "version-control/dump-prompt.txt",
    "version-control/dump-undo.js",
    "version-control/dump-validator.js",
    "version-control/generate-dump.js",
    "version-control/print-active.js",
    "views/dashboard.pug",
    "views/error.pug",
    "views/layout.pug"
  ]
}
